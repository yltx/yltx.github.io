<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 CF660C 【Hard Process】]]></title>
    <url>%2F2019%2F02%2F10%2F%E9%A2%98%E8%A7%A3-CF660C-%E3%80%90Hard-Process%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到C++的都是二分的尺取法表示不服 这题朴素想法：枚举l，r，暴力求[l,r]中0的个数是否小于k，复杂度$O(n^{3})$ 我们想想有没有什么优化的办法 很明显，对于一个含0的区间，我们让区间中的0都填满是最优的 于是维护一段区间，保证区间中的0的个数≤k就可以 于是就可以对于0的个数≤k时右移右端点，增添新的位置，扩大区间； 当[l,r]中0的个数＞k时我们没有必要再回到l从头开始，可以只右移l，到[l,r]中0的个数≤k时为止（其实最后肯定=k，自己想想为什么！） 于是复杂度降到了线性的$O(n)$，或成此题最优解？ 并不长的代码： #include &lt;bits/stdc++.h&gt; using namespace std; int a[300005],k,n,ans,cnt,ml,mr; int main(){ scanf (&quot;%d%d&quot;,&amp;n,&amp;k); for (int i=1;i&lt;=n;i++)scanf (&quot;%d&quot;,&amp;a[i]); for (int l=1,r=1;r&lt;=n;r++){//持续右移右端点 cnt+=!a[r]; if (cnt&gt;k){ cnt-=!a[l]; l++; }//长了就右移左端点 if (r-l+1&gt;ans)ans=r-l+1,ml=l,mr=r; } for (;ml&lt;=mr;ml++)a[ml]=1; printf (&quot;%d\n&quot;,ans); for (int i=1;i&lt;=n;i++)printf (&quot;%d &quot;,a[i]); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 UVA11366 【Circle of Debt】]]></title>
    <url>%2F2019%2F02%2F10%2F%E9%A2%98%E8%A7%A3-UVA11366-%E3%80%90Circle-of-Debt%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意： A欠B $ab$ 元，B欠C $bc$ 元，C欠A $ca$ 元。现在告诉你每个人的100元，50元，20元，10元，5元，1元的硬币各有多少个，问你最少需要交换多少张硬币才能还清他们之间的债务。（当$ab$=$bc$=$ca$时就可以认为债务已经还清）无法还清输出$impossible$每个人最多有30张硬币，他们的总钱数不多与1000元。——FlierKing的课件 这个麻烦管理员顺手搬到题面上。 这题目一看就是搜索 但纯爆搜是肯定要T的 首先是一个基本性的优化： 对于每个币种，只可能有两种情况： 两个人给一个人钱 一个人给两个人钱 那么搜索的复杂度就减少了 然后是两个非常常见的优化： 最优性剪枝：如果当前的答案已经不如已有的答案了，剪枝； 可行性剪枝：我们考虑先搜索面值小的硬币，然后搜索大面值的硬币时，每两个人直接的欠的金额差必须可以被此时剩下面值的硬币的最大公因数整除，不然这两个人之间就永远纠缠不清。 加上这些优化代码AC就没什么问题了。 代码： #include&lt;bits/stdc++.h&gt; #define inf 2147483647 using namespace std; int t,d[3],ans,cnt,u[3][6],td[3],a[6][4]; const int v[]={100,50,20,10,5,1};//币种数组 bool check(int x,int y){//暴力判可行 switch(y){ case 5:return true; case 4:return x%5==0; case 2:return x%10==0; case 1:return x%50==0; case 0:return x%100==0; } } void dfs(int x){ if(x&lt;0){if(td[0]==td[1]&amp;&amp;td[1]==td[2])ans=min(ans,cnt);return;}//债务还清了，更新答案 if(cnt&gt;=ans)return;//最优性剪枝 if(!check(td[0]-td[1],x)||!check(td[1]-td[2],x))return;//可行性剪枝 for(int i=0;i&lt;3;i++){ int nex=(i+1)%3,pre=(i+2)%3; for(int j=0;j&lt;=u[i][x];j++) for(int k=0;k&lt;=u[i][x]-j;k++){ td[i]-=j*v[x],td[pre]+=k*v[x],cnt+=j+k; dfs(x-1); cnt-=j+k,td[i]+=j*v[x],td[pre]-=k*v[x]; } for(int j=0;j&lt;=u[nex][x];j++) for(int k=0;k&lt;=u[pre][x];k++){ td[i]+=j*v[x],td[pre]-=k*v[x],cnt+=j+k; dfs(x-1); cnt-=j+k,td[i]-=j*v[x],td[pre]+=k*v[x]; } } } int main(){ scanf (&quot;%d&quot;,&amp;t); while(t--){ ans=inf; for(int i=0;i&lt;3;i++)scanf (&quot;%d&quot;,&amp;td[i]),d[i]=td[i]; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;6;j++)scanf (&quot;%d&quot;,&amp;u[i][j]); dfs(5); if(ans==inf)puts(&quot;impossible&quot;); else printf(&quot;%d\n&quot;,ans); } return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年离我们而去的Oier们]]></title>
    <url>%2F2019%2F01%2F22%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E7%A6%BB%E6%88%91%E4%BB%AC%E8%80%8C%E5%8E%BB%E7%9A%84Oier%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[我自己也算是半个退役的人了，所以看到别人离去，觉得我自己的那一天也不远了 所以就开始搞这个。 $ \color{blue} \text{strangers} $退役于2018.11.08。 这位巨佬特强 看题目统计就知道 $ \color{white} \colorbox{grey}{尚无评定} $ 7 $ \color{white} \colorbox{red}{入门难度} $ 58 $ \color{white} \colorbox{orange}{普及-} $ 98 $ \color{white} \colorbox{yellow}{普及/提高-} $ 123 $ \color{white} \colorbox{green}{普及+/提高} $ 85 $ \color{white} \colorbox{blue}{提高+/省选-} $ 294 $ \color{white} \colorbox{purple}{省选/NOI-} $ 331 $ \color{white} \colorbox{black}{NOI/NOI+/CTSC} $ 32 称“切黄题”为颓废、高二入坑高三退坑时就已经能AK IOI的人。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建食用指北]]></title>
    <url>%2F2019%2F01%2F18%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[最近打算自己搭个blog，于是就看了很多有关的文章 比较有用的：https://ouuan.github.io/hexo博客搭建指北/ 嗯嗯有些不够详细的我来说一说 域名域名的申请土豪请略过，我这里谈的是免费的 首先打开freenom 网站打开可能会有点慢，先看看别的网页，耐心等等 重要！不要试图将语言切换为中文，至少在我的浏览器上中文会挂，网页都失去了功能 搜索你想要的域名 别问我为什么是这个域名 选择你想要的 结算 进入结算页面 比方说你想保留kkksc03.ml 那么kkksc03.tk就设置成跳转到kkksc03.ml 先点1，把3 Months @FREE改成12 Months @FREE 不然你的域名有效期只有3个月 然后点你要保留的域名中的2(Use DNS) 点3(Use your own DNS) 选择你的DNS服务商： 建议： dnspod Cloudflare 连接域名和DNS dnspod在5处填f1g1ns1.dnspod.net 在6处填f1g1ns2.dnspod.net 然后打开dnspod 登录 点域名解析 点添加域名 输入你的主域名（即域名的后半部分） 例：www.kkksc03.ml-&gt;kkksc03.ml 点确定 等它一下 导好之后 确认就可以 添加记录 添加一个www记录，一个@记录（这样保险） 然后记录值随便输一个***.***.***.***类型的就可以 保存 Cloudflare5处填mimi.ns.cloudflare.com 6处填oswald.ns.cloudflare.com Cloudflare的注册等会再说 回到freenom 点continue 进入账单 在左下角”Enter Your Email Address”的位置输入你的邮箱（部分邮箱用不了），点下面的蓝色按钮注册 我已经有账号了所以我点右上角的”Sign in”直接登录了 然后域名就申请好了 Hexo blog注：这里只介绍next主题。 根目录下的_config.yml好像只有一点东西可以设啊 作者应该在第10行的位置 author: yourname 把yourname改成你的名字即可。 语言应该在第11行的位置 language: zh-CN 这样页面语言就是中文了。 主题目录下的_config.yml这部分基本上就是抄的了，我只是解释一下 选择4种主题中的一种# Schemes scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini 把想要的那一种前面的#去掉，不想要的加上即可。 改变网站图标favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 把你想要的图标放到\themes\next\source\images里，然后修改上面的文件名即可。 注：大小要符合 页脚设置footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.0/icons # `heart` is recommended with animation in red (#ff0000). name: battery-full # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: &quot;#808080&quot; # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp: icon： © 2019 与用户名之间的图标。（图中 1） 图标名称为 Font Awesome 上的图标名称。 powered.enable：为 true 则会显示 “由 Hexo 强力驱动”。（图中 2 ） powered.version：为 true 则会显示 Hexo 的版本。（图中 3 ） powered.enable：为 true 则会显示“主题 – NexT.XX”。（图中 4） powered.version：为 true 则会显示主题的版本。（图中 5） 搬运Markdown好累啊 “关于”&amp;“标签”menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 将需要的项目取消注释即可在侧边栏显示。 如果需要使用“关于”页面，输入命令 hexo new page &quot;about&quot;。 然后在 \source\about\index.md 中就可以编辑“关于”页面了。 可以修改 \source\about\index.md 中的 title 项来显示“关于”而非“about”。 如果需要使用“标签”功能，需要在博文中添加选项 tags ： 如果有多个标签，每行一个，以 - 开头： tags: - 标签1 - 标签2 - 标签3 如果需要使用“标签”页面，输入命令 hexo new page &quot;tags&quot;。 然后向 source\tags\index.md 中添加一行： type: &quot;tags&quot; 站内搜索输入命令 npm install hexo-generator-searchdb --save 安装所需的库。 在根目录下的 _config.yml 的结尾加入： search: path: search.xml field: post format: html limit: 10000 然后在 \themes\next\_config.yml 中，打开 local_search： local_search: enable: true 社♂交网站# Social Links. # Usage: `Key: permalink || icon` # Key is the link label showing to end users. # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded. social: GitHub: https://github.com/yltx || github 洛谷: https://www.luogu.org/space/show?uid=39863 || code Codeforces: https://www.codeforces.com/profile/yltx || code b站: https://space.bilibili.com/11067182 || tv social_icons: enable: true icons_only: false transition: false 在 social 下每行一个，格式为：名称: 地址 || 图标。 其中，“图标”为 Font Awesome 图标名称，但有些图标是不可用的，而且图标也不全，使用的时候要尝试一下图标是否可用。 social_icons: enable: false 这样设置可以只显示名称不显示图标。 友情链接（或其它链接）# Blog rolls links_icon: globe links_title: 友链 # links_layout: block links_layout: inline links: 引领天下: https://www.yltx.cf links_icon：显示在标题前的图标。 links_title：标题。 links_layout：block 一行一个，inline 一行多个。 links：要显示的链接以及名称。 头像# Sidebar Avatar avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url：头像地址，留空则不显示头像。 rounded：圆/方头像。 opacity：不透明度。 rotated：随光标旋转。 回到顶部按钮/阅读百分比# Back to top in sidebar (only for Pisces | Gemini). b2t: true # Scroll percent label in b2t button. scrollpercent: true 博客首页不显示全文在博文里可以用 &lt;!-- more --&gt; 来标识在首页显示到哪为止。 可以在 \themes\next\_config.yml 里设置到一定字数自动不显示全文： # Automatically Excerpt. Not recommend. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: true length: 150 # Read more button # If true, the read more button would be displayed in excerpt section read_more_btn: true length：不显示全文的字数上限。 read_more_btn： 代码块复制按钮codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true enable：启用复制按钮。 show_result： $\LaTeX$# Math Equations Render Support math: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has &#39;mathjax: true&#39; in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: false engine: mathjax #engine: katex enable：启用$\LaTeX$。 per_page：为 true 则只有博文中有 mathjax: true 才会启用$\LaTeX$，否则每篇博客都会启用$\LaTeX$。 engine：推荐使用 mathjax 。 hexo 博客的 mathjax 和 Markdown 有一些冲突，将在后文专门讲解如何解决冲突。 评论功能由于 gitment 的服务器有一些问题，推荐使用 gitalk： gitalk: enable: true github_id: yourname repo: yourname.github.io client_id: client_secret: admin_user: yourname 这里需要在 GitHub 新建一个 OAuth App，“Homepage URL”和“Authorization callback URL”填你的域名（如果没有申请域名的话就填 yourname.github.io）： 需要注意的是，地址要严格和博客访问地址一样，http 和 https不能混，有无 www 也不能混。 然后将 Client ID 和 Client Secret 填入 \themes\next\_config.yml 中。 访客记录busuanzi_count: enable: true 书签书签的功能是关闭页面/手动点击书签按钮时，保存这篇博客看到的位置，下次点进这篇博客时继续从这个位置开始。 安装插件： git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark 更改 \themes\next\_config.yml： # Bookmark Support # Dependencies: https://github.com/theme-next/theme-next-bookmark bookmark: enable: true # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: manual 其他配置博客背景打开 \themes\next\source\css\_custom\custom.styl，输入： body { background-image:url(/images/background.jpg); background-size: cover; } 把背景图片重命名为 background.jpg，放入 \themes\source\images（当然也可以更改background-image:url()）。 background-size: cover; 表示宽度缩放至页面大小。 body { background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-size: cover; } 如果修改成这样的话背景图片就不会滚动。 如果不想让博客内容挡住背景，可以设置博客内容的透明度，在 \themes\next\source\css\_custom\custom.styl 中加入下面的代码即可： .main-inner { opacity: 0.8; } README.md如果想在 https://github.com/yourname/yourname.github.io 让别人看到你的博客的简介，就需要写一个 README.md 放在根目录下的 source 文件夹内。 然而，只是这样的话， README.md 会被渲染成 html，所以需要更改根目录下 _config.yml 的设置： skip_render: README.md 自定义404页面首先写一个 \source\404.html 。 至于怎么写html..这里地方太小写不下作者也不会 事实上可以新建一篇博客，用 Markdown 写一个 404 页面，然后 hexo g 在 \public 里找到博客的页面，把相关部分直接复制过来。 可以参考一下我的： &lt;body&gt; &lt;div&gt; &lt;p style=&quot;text-align: center;&quot;&gt;&lt;strong&gt;您可能访问了错误的网址&lt;/strong&gt;&lt;img src=&quot;https://i.loli.net/2019/01/24/5c49c41569ceb.gif&quot;&gt;&lt;/p&gt; &lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;https://www.ouuan.cf&quot;&gt;&lt;strong&gt;回到博客主页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;javascript:history.go(-1);&quot;&gt;&lt;strong&gt;返回上一页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/html&gt; 发布效果： 您可能访问了错误的网址 回到博客主页 返回上一页 然后，如果直接这样发布，html 会被渲染，就跟一个自定义页面（hexo new page）一样了。 所以要修改根目录下的 _config.yml，在 skip_render: 后添加 404.html，如果有多项用 - 隔开： skip_render: - README.md - 404.html 发布完成后，访问一个错误的网址，比如 你的域名/qaq 就可以查看效果了。 原文 连接github配置github仓库首先你要有一个github账号…… 然后登录 新建一个repo： 输入名字，保存： 注意：yourname要换成你的githubID。 比方说我的就是yltx.github.io 然后点2就可以了。 上传在本地输入： ssh-keygen 让你输东西就空着，按回车就行（应该要三次吧） 输入命令： cat ~/.ssh/id_rsa.pub 复制窗口中出现的一堆乱码一样的东西 然后回到github，点头像打开Settings 点击左侧的SSH and GPG keys 我的已经有一个了不用管 点New SSH Keys，新建一个，标题随便，把刚才复制的一堆东西粘贴进去，然后点”Add SSH key”就行了。 然后在本地输入命令 ssh -T git@github.com 若出现Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access就表示SSH配置成功了 输入命令 npm install hexo-deployer-git --save 就可以安装deployer。 打开根目录（在本地创建的那个文件夹）下的_config.yml，在最后输入： deploy: type: git repository: https://github.com/yourname.github.io.git branch: master 当然yourname要改成你的Github ID了。 输入命令： hexo cl hexo g hexo d 这一步可能要输入密码（出现一个弹框） 以后可以用简化的命令： hexo cl hexo g -d 等几分钟，打开yourname.github.io应该就可以看到你的博客了。 那么恭喜你，你上传好了。 连接域名和github先在hexo根目录的source子目录下新建文件CNAME（重要！没有.txt之类的后缀名！） 然后打开，输入你的域名（注意，如果使用gitalk，在此处输入的域名必须与App中的一样） 例： CNAME： yltx.cf App： https://yltx.cf 千万不能随便加www！要加要一起加！ dnspod在本地打开cmd（命令提示符），输入命令： ping yourname.github.io yourname要换成你自己的githubID。 会出来一个IP地址： 我红笔圈出来的部分 然后打开dnspod中你之前添加的域名 把这个IP填到之前dnspod我们瞎填111.111.111.111的地方，保存 Cloudflare打开Cloudflare官网 有的登录，没的注册 登录好了之后： 点右上角的Add Site，输入你的域名 添加好之后 接下来肯定是点Next啦 咳咳咳选哪个套餐就看你有多少钱啦 我选的是FREE 点Confirm Plan 再点一次Confirm 不要问我为什么换了域名，因为Cloudflare要求要存在的域名，而我并没有真的申请kkksc03.ml 然后点continue应该就可以了 在本地输入命令： hexo d 过几分钟域名应该就可以用了。 开启https如果不开启的话，访问 https://你的域名 就会显示警告，访问 http://你的域名 就会显示不安全。 当然如果因为某种原因访问 https://你的域名 已经不会显示警告而且浏览器左上角有绿锁了，就不需要再进行额外的设置了。 其实很简单，浏览器打开https://github.com/yourname/yourname.github.io/settings，找到这里： （我已经开过了） 勾选Enforce HTTPS即可。 停用域名单纯停用只需删去 CNAME 文件即可，然后记得更改相关设置（在各种地方引用的博客链接、OAuth App 地址……）。 Q&amp;AQ1Q：“Enforce HTTPS”前面是灰色的，无法打勾 A： 删掉“Save”前面的域名，点击“Save”。 重新输入域名，点击“Save”。 重新发布博客（hexo d）。 等待几分钟~几小时，再访问你的博客应该就OK了。 Q2Q：gitalk用不了 A：检查App和CNAME域名是否相同（上文说过） 特殊的：如果开启了https则URL一定要填https。 Q3Q：停用域名不成功，即：在电脑上访问博客还是自动跳转到原有域名 A： 按F12 点Network 勾选Disable Cache 按Ctrl+F5强制刷新 取消勾选 方法来源 附录常用命令hexo cl 删除编译文件夹public，方便重新编译 hexo g 编译。 hexo d 上传。 hexo g -d 编译后上传。 hexo new page &quot;xxx&quot; 新建一个以“xxx”为名的页面，md文件直接存放在\source文件夹下。 hexo n &quot;xxx&quot; 新建一篇以“xxx”为名的博文，md文件存放在\source\_posts文件夹下。 原始的next主题的_config.yml方便您备份。 # --------------------------------------------------------------- # Theme Core Configuration Settings # --------------------------------------------------------------- # If false, merge configs from `_data/next.yml` into default configuration (rewrite). # If true, will fully override default configuration by options from `_data/next.yml` (override). Only for NexT settings. # And if true, all config from default NexT `_config.yml` must be copied into `next.yml`. Use if you know what you are doing. # Useful if you want to comment some options from NexT `_config.yml` by `next.yml` without editing default config. override: false # Allow to cache content generation. Introduced in NexT v6.0.0. cache: enable: true # Redefine custom file paths. Introduced in NexT v6.0.2. # If commented, will be used default custom file paths. # For example, you want to put your custom styles file # outside theme directory in root `source/_data`, set # `styles: source/_data/styles.styl` #custom_file_path: # Default paths: layout/_custom/* #head: source/_data/head.swig #header: source/_data/header.swig #sidebar: source/_data/sidebar.swig # Default path: source/css/_variables/custom.styl #variables: source/_data/variables.styl # Default path: source/css/_mixins/custom.styl #mixins: source/_data/mixins.styl # Default path: source/css/_custom/custom.styl #styles: source/_data/styles.styl # --------------------------------------------------------------- # Site Information Settings # --------------------------------------------------------------- # To get or check favicons visit: https://realfavicongenerator.net # Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory. # Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory. # And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes. # For example, you put your favicons into `hexo-site/source/images` directory. # Then need to rename &amp; redefine them on any other names, otherwise icons from Next will rewrite your custom icons in Hexo. favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml # Set rss to false to disable feed link. # Leave rss as empty to use site&#39;s feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`. # Set rss to specific value if you have burned your feed already. rss: footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: user # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: &quot;#808080&quot; # If not defined, `author` from Hexo main config will be used. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: true # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp: # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a href=&quot;https://pages.coding.me&quot; class=&quot;theme-link&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Coding Pages&lt;/a&gt; # Creative Commons 4.0 International License. # https://creativecommons.org/share-your-work/licensing-types-examples # Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero creative_commons: license: by-nc-sa sidebar: false post: false # --------------------------------------------------------------- # SEO Settings # --------------------------------------------------------------- # Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog. # See: https://support.google.com/webmasters/answer/139066 # Tips: Before you open this tag, remember set up your URL in hexo _config.yml (e.g. url: http://yourdomain.com) canonical: true # Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization. seo: false # If true, will add site-subtitle to index page, added in main hexo config. # subtitle: Subtitle index_with_subtitle: false # Automatically add external URL with BASE64 encrypt &amp; decrypt. exturl: false # --------------------------------------------------------------- # Menu Settings # --------------------------------------------------------------- # When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives). # Usage: `Key: /link/ || icon` # Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive. # Value before `||` delimeter is the target link. # Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded. # External url should start with http:// or https:// menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat # Enable/Disable menu icons / item badges. menu_settings: icons: true badges: false # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini # --------------------------------------------------------------- # Sidebar Settings # --------------------------------------------------------------- # Posts / Categories / Tags in sidebar. site_state: true # Social Links # Usage: `Key: permalink || icon` # Key is the link label showing to end users. # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded. #social: #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons: enable: true icons_only: false transition: false # Follow me on GitHub banner in right-top corner. # Usage: `permalink || title` # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the title and aria-label name. #github_banner: https://github.com/yourname || Follow me on GitHub # Blog rolls links_icon: link links_title: Links links_layout: block #links_layout: inline #links: #Title: http://example.com # Sidebar Avatar avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: #/images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: false # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false # Table Of Contents in the Sidebar toc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false # Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` var. max_depth: 6 sidebar: # Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left #position: right # Manual define the sidebar width. # If commented, will be default for: # Muse | Mist: 320 # Pisces | Gemini: 240 #width: 300 # Sidebar Display, available values (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar. b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false # --------------------------------------------------------------- # Post Settings # --------------------------------------------------------------- # Automatically scroll page to section which is under &lt;!-- more --&gt; mark. scroll_to_more: true # Automatically saving scroll position on each post/page in cookies. save_scroll: false # Automatically excerpt description in homepage as preamble text. excerpt_description: true # Automatically Excerpt. Not recommend. # Use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: false length: 150 # Read more button # If true, the read more button would be displayed in excerpt section. read_more_btn: true # Post meta display settings post_meta: item_text: true created_at: true updated_at: enabled: true # If true, show updated date label only if `updated date` different from `created date` (post edited in another day than was created). # And if post will edited in same day as created, edited time will show in popup title under created time label. # If false show anyway, but if post edited in same day, show only edited time. another_day: true categories: true # Post wordcount display settings # Dependencies: https://github.com/theme-next/hexo-symbols-count-time symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: false # Show text copy result show_result: false # Wechat Subscriber #wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode e.g. /uploads/wechat-qcode.jpg #description: e.g. subscribe to my blog by scanning my public wechat account # Reward # If true, reward would be displayed in every article by default. # And you can show or hide one article specially through add page variable `reward: true/false`. reward: enable: false #comment: Donate comment here #wechatpay: /images/wechatpay.jpg #alipay: /images/alipay.jpg #bitcoin: /images/bitcoin.jpg # Related popular posts # Dependencies: https://github.com/tea3/hexo-related-popular-posts related_posts: enable: false title: # custom header, leave empty to use the default one display_in_home: false params: maxCount: 5 #PPMixingRate: 0.0 #isDate: false #isImage: false #isExcerpt: false # Post edit # Dependencies: https://github.com/hexojs/hexo-deployer-git post_edit: enable: false url: https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name # Link for view source. #url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name # Link for fork &amp; edit. # --------------------------------------------------------------- # Misc Theme Settings # --------------------------------------------------------------- # Disable Baidu tranformation on mobile devices. disable_baidu_tranformation: false # Reduce padding / margin indents on devices with narrow width. mobile_layout_economy: false # Android Chrome header panel color ($brand-bg / $headband-bg =&gt; $black-deep). android_chrome_color: &quot;#222&quot; # Custom Logo # Do not support Scheme Mist currently. # Options: # enabled: If true, will enable custom logo # image: Images&#39;s url, replace it with specific image custom_logo: enabled: false image: # Code Highlight theme # Available values: normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: normal # Enable &quot;cheers&quot; for archive page. cheers_enabled: true # --------------------------------------------------------------- # Font Settings # - Find fonts on Google Fonts (https://www.google.com/fonts) # - All fonts set here will have the following styles: # light, light italic, normal, normal italic, bold, bold italic # - Be aware that setting too much fonts will cause site running slowly # - Introduced in 5.0.1 # --------------------------------------------------------------- # CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844 # To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`): # Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS # --------------------------------------------------------------- font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used for all elements in &lt;body&gt;. global: external: true family: Lato size: # Font settings for Headlines (H1, H2, H3, H4, H5, H6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: # --------------------------------------------------------------- # Third Party Services Settings # --------------------------------------------------------------- # Math Equations Render Support math: enable: false # Default(true) will load mathjax/katex script on demand # That is it only render those page who has `mathjax: true` in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true engine: mathjax #engine: katex # hexo-rendering-pandoc (or hexo-renderer-kramed) needed to full MathJax support. mathjax: # Use 2.7.1 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML # For direct link to MathJax.js with CloudFlare CDN (cdnjs.cloudflare.com) #cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML # See: https://mhchem.github.io/MathJax-mhchem/ #mhchem: //cdn.jsdelivr.net/npm/mathjax-mhchem@3 #mhchem: //cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0 # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) needed to full Katex support. katex: # Use 0.7.1 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/katex@0.7.1/dist/katex.min.css # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China #cdn: //cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css copy_tex: # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex enable: false copy_tex_js: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js copy_tex_css: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css # PDF Support # Dependencies: https://github.com/theme-next/theme-next-pdf pdf: enable: false # Default(true) will load PDFObject/PDF.js script on demand # That is it only render those page who has `pdf: true` in Front Matter. # If you set it to false, it will load PDFObject/PDF.js srcipt EVERY PAGE. per_page: true height: 500px pdfobject: # Use 2.1.1 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China #cdn: //cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js # Han Support # Dependencies: https://github.com/theme-next/theme-next-han han: false # Pangu Support # Dependencies: https://github.com/theme-next/theme-next-pangu # For more information: https://github.com/vinta/pangu.js pangu: false # Swiftype Search API Key #swiftype_key: # Baidu Analytics ID #baidu_analytics: # Growingio Analytics ID # Copyright 2015-2018 GrowingIO, Inc. More info available at https://www.growingio.com #growingio_analytics: #your projectId # Disqus disqus: enable: false shortname: count: true lazyload: false # Changyan changyan: enable: false appid: appkey: # Valine # You can get your appid and appkey from https://leancloud.cn # More info available at https://valine.js.org valine: enable: false # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#39; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page # Support for LiveRe comments system. # You can get your uid from https://livere.com/insight/myCode (General web site) #livere_uid: your uid # Gitment # Introduction: https://github.com/imsun/gitment gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &#39;Powered by ...&#39; on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github Username github_repo: # MUST HAVE, The name of the repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled # Gitalk # Demo: https://gitalk.github.io # Reference: https://asdfv1929.github.io/2018/01/20/gitalk/, https://liujunzhou.cn/2018/8/10/gitalk-error/#more gitalk: enable: false github_id: # Github repo owner repo: # Repository name to store issues. client_id: # Github Application Client ID client_secret: # Github Application Client Secret admin_user: # GitHub repo owner and collaborators, only these guys can initialize github issues distraction_free_mode: true # Facebook-like distraction free mode # Baidu Share # Available values: # button | slide # Warning: Baidu Share does not support https. #baidushare: ## type: button # AddThis Share, See: https://www.addthis.com # Go to https://www.addthis.com/dashboard to customize your tools #add_this_id: # NeedMoreShare2 # Dependencies: https://github.com/theme-next/theme-next-needmoreshare2 # See: https://github.com/revir/need-more-share2, https://github.com/DzmVasileusky/needShareButton # iconStyle: default | box # boxForm: horizontal | vertical # position: top / middle / bottom + Left / Center / Right # networks: # Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus, # Slashdot,Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailru needmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook # Google Webmaster tools verification setting # See: https://www.google.com/webmasters #google_site_verification: # Google Analytics #google_analytics: # Bing Webmaster tools verification setting # See: https://www.bing.com/webmaster #bing_site_verification: # Yandex Webmaster tools verification setting # See: https://webmaster.yandex.ru #yandex_site_verification: # Baidu Webmaster tools verification setting # See: https://ziyuan.baidu.com/site #baidu_site_verification: # CNZZ count #cnzz_siteid: # Application Insights # See: https://azure.microsoft.com/en-us/services/application-insights #application_insights: # Post widgets &amp; FB/VK comments settings. # --------------------------------------------------------------- # Facebook SDK Support. # https://github.com/iissnan/hexo-theme-next/pull/410 facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true # Facebook comments plugin # This plugin depends on Facebook SDK. # If facebook_sdk.enable is false, Facebook comments plugin is unavailable. facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark) # VKontakte API Support # To get your AppID visit https://vk.com/editapp?act=create vkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10 # Star rating support to each article. # To get your ID visit https://widgetpack.com rating: enable: false id: #&lt;app_id&gt; color: fc6423 # --------------------------------------------------------------- # Show number of visitors to each article. # You can visit https://leancloud.cn get AppID and AppKey. leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&#39;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: true betterPerformance: false # Another tool to show number of visitors to each article. # Visit https://console.firebase.google.com/u/0/ to get apiKey and projectId. # Visit https://firebase.google.com/docs/firestore/ to get more information about firestore. firestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill # Show Views/Visitors of the website/page with busuanzi. # Get more information on http://ibruce.info/2015/04/04/busuanzi busuanzi_count: enable: false total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye # Tencent analytics ID #tencent_analytics: # Tencent MTA ID #tencent_mta: # Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO. baidu_push: false # Google Calendar # Share your recent schedule to others via calendar page. # API Documentation: https://developers.google.com/google-apps/calendar/v3/reference/events/list # Enabled APIs and services # api_key: https://console.developers.google.com # Create &amp; manage a public Google calendar: https://support.google.com/calendar/answer/37083 calendar: enable: false calendar_id: &lt;required&gt; # Your Google account E-Mail api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 # Time Range offsetMin: 4 # Time Range showDeleted: false singleEvents: true maxResults: 250 # Algolia Search # See: https://github.com/theme-next/hexo-theme-next/blob/master/docs/ALGOLIA-SEARCH.md # Dependencies: https://github.com/theme-next/theme-next-algolia-instant-search algolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: &quot;We didn&#39;t find any results for the search: ${query}&quot; hits_stats: &quot;${hits} results found in ${time} ms&quot; # Local search # Dependencies: https://github.com/theme-next/hexo-generator-searchdb local_search: enable: false # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false # Bookmark Support # Dependencies: https://github.com/theme-next/theme-next-bookmark bookmark: enable: false # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: auto # --------------------------------------------------------------- # Tags Settings # --------------------------------------------------------------- # See: https://theme-next.org/docs/tag-plugins/ # Note tag (bs-callout) note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 # Label tag label: true # Tabs tag tabs: enable: true transition: tabs: false labels: true border_radius: 0 # Reading progress bar # Dependencies: https://github.com/theme-next/theme-next-reading-progress reading_progress: enable: false color: &quot;#37c6c0&quot; height: 2px #! --------------------------------------------------------------- #! DO NOT EDIT THE FOLLOWING SETTINGS #! UNLESS YOU KNOW WHAT YOU ARE DOING #! --------------------------------------------------------------- # Use velocity to animate everything. motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn # Fancybox. There is support for old version 2 and new version 3. # Choose only any one variant, do not need to install both. # To install 2.x: https://github.com/theme-next/theme-next-fancybox # To install 3.x: https://github.com/theme-next/theme-next-fancybox3 fancybox: false # Added switch option for separated repo in 6.0.0. # Dependencies: https://github.com/theme-next/theme-next-fastclick fastclick: false # Added switch option for separated repo in 6.0.0. # Dependencies: https://github.com/theme-next/theme-next-jquery-lazyload lazyload: false # Progress bar in the top during page loading. # Dependencies: https://github.com/theme-next/theme-next-pace pace: false # Themes list: # pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom # pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator # pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimal # For example # pace_theme: pace-theme-center-simple pace_theme: pace-theme-minimal # Canvas-nest # Dependencies: https://github.com/theme-next/theme-next-canvas-nest canvas_nest: enable: false onmobile: true # display on mobile or not color: &#39;0,0,255&#39; # RGB values, use &#39;,&#39; to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines # JavaScript 3D library. # Dependencies: https://github.com/theme-next/theme-next-three # three_waves three_waves: false # canvas_lines canvas_lines: false # canvas_sphere canvas_sphere: false # Canvas-ribbon # Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon # size: The width of the ribbon. # alpha: The transparency of the ribbon. # zIndex: The display level of the ribbon. canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1 # Script Vendors. # Set a CDN address for the vendor you want to customize. # For example # jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js # Be aware that you should use the same version as internal ones to avoid potential problems. # Please use the https protocol of CDN files when you enable https on your site. vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 # Example: # jquery: //cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js # jquery: //cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js jquery: # Internal version: 2.1.5 # See: https://fancyapps.com/fancybox # Example: # fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js # fancybox: //cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.min.js # fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css # fancybox_css: //cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.min.css fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick # Example: # fastclick: //cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js # fastclick: //cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload # Example: # lazyload: //cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js # lazyload: //cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org # Example: # velocity: //cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js # velocity: //cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js # velocity_ui: //cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js # velocity_ui: //cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js velocity: velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js # Example: # ua_parser: //cdn.jsdelivr.net/npm/ua-parser-js@0/src/ua-parser.min.js # ua_parser: //cdnjs.cloudflare.com/ajax/libs/UAParser.js/0.7.9/ua-parser.min.js ua_parser: # Internal version: 4.6.2 # See: https://fontawesome.com # Example: # fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css # fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css fontawesome: # Internal version: 2.4.1 # See: https://www.algolia.com # Example: # algolia_instant_js: //cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.js # algolia_instant_css: //cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Example: # pace: //cdn.jsdelivr.net/npm/pace-js@1/pace.min.js # pace: //cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js # pace_css: //cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css # pace_css: //cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css pace: pace_css: # Internal version: 1.0.0 # See: https://github.com/theme-next/theme-next-canvas-nest # Example: # canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js # canvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js canvas_nest: canvas_nest_nomobile: # Internal version: 1.0.0 # See: https://github.com/theme-next/theme-next-three # Example: # three: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js # three_waves: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js # canvas_lines: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js # canvas_sphere: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_sphere.min.js three: three_waves: canvas_lines: canvas_sphere: # Internal version: 1.0.0 # See: https://github.com/zproo/canvas-ribbon # Example: # canvas_ribbon: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js canvas_ribbon: # Internal version: 3.3.0 # See: https://github.com/ethantw/Han # Example: # han: //cdn.jsdelivr.net/npm/han-css@3/dist/han.min.css # han: //cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css han: # Internal version: 3.3.0 # See: https://github.com/vinta/pangu.js # Example: # pangu: //cdn.jsdelivr.net/npm/pangu@3/dist/browser/pangu.min.js # pangu: //cdnjs.cloudflare.com/ajax/libs/pangu/3.3.0/pangu.min.js pangu: # Internal version: 1.0.0 # See: https://github.com/revir/need-more-share2 # Example: # needmoreshare2_js: //cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js # needmoreshare2_css: //cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css needmoreshare2_js: needmoreshare2_css: # Internal version: 1.0.0 # See: https://github.com/theme-next/theme-next-bookmark # Example: # bookmark: //cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1/bookmark.min.js bookmark: # Internal version: 1.1 # See: https://github.com/theme-next/theme-next-reading-progress # Example: # reading_progress: //cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1/reading_progress.min.js reading_progress: # leancloud-storage # See: https://www.npmjs.com/package/leancloud-storage # Example: # leancloud: //cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js leancloud: # valine # See: https://github.com/xCss/Valine # Example: # valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js # valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js valine: # gitalk # See: https://github.com/gitalk/gitalk # Example: # gitalk_js: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js # gitalk_css: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css gitalk_js: gitalk_css: # js-md5 # See: https://github.com/emn178/js-md5 # Example: # md5: //cdn.jsdelivr.net/npm/js-md5@0/src/md5.min.js md5: # Assets css: css js: js images: images]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1482 【Cantor表（升级版）】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1482-%E3%80%90Cantor%E8%A1%A8%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[我想问一下楼下是肿么想的。 写了读入优化不用。。。。。 还有求最大公约数何必暴力？？ 额额。 以上是个人吐槽内容。 重点来了！ 首先，你要知道： 约分后的分母是行，分子是列。 于是问题来了： 怎么约分？ 很简单：用辗转相除法求最大公约数，然后约分。 然后输出。 完事。 让路 代码上： #include&lt;bits/stdc++.h&gt;//包含所有头文件的头文件 using namespace std;//为了用流，写它 int gcd(int a,int b){//辗转相除法求最大公约数 if (!b)return a;//如果b==0，a是最大公约数 else return gcd(b,a%b);//不然继续 } int main(){ ios::sync_with_stdio(false);//流优化 int a,b,c,d,t; char hh;//这家伙对付‘/’号 cin&gt;&gt;a&gt;&gt;hh&gt;&gt;b&gt;&gt;c&gt;&gt;hh&gt;&gt;d;//读入，不解释 a*=c;b*=d;//乘一下 t=gcd(a,b);//求最大公约数 a/=t,b/=t;//约分 cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a;//输出 return 0;//庄严地结束 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1138 【第k小整数】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1138-%E3%80%90%E7%AC%ACk%E5%B0%8F%E6%95%B4%E6%95%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实，这题可以很简单。 首先，读入n和k; 然后，读入n个整数; 读入时去重。 去完了就排序。 然后输出。 OK！！！！！！ 上代码：（c++） #include &lt;bits/stdc++.h&gt;//包含所有头文件的头文件 using namespace std; int n,a[10005],i,k;//不解释 bool s[30005];//用来去重的桶 int main(void){ scanf (&quot;%d%d&quot;,&amp;n,&amp;k); for (;i&lt;n;i++){ scanf (&quot;%d&quot;,&amp;a[i]);//读入 if (s[a[i]])n--,i--;//如果出现过了，总数--，i--（重读a[i]） else s[a[i]]=1;//不然标记一下 }//读完了就去重完了//这就是我的和别的调解不同的地方：我用桶去重。 sort (a,a+n);//排序！ if (n&lt;k||k&lt;=0)printf (&quot;NO RESULT&quot;);//坑人的#3、5、8 else printf (&quot;%d&quot;,a[k-1]);//因为我是0下标，所以k要-1 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1897 【电梯里的爱情】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1897-%E3%80%90%E7%94%B5%E6%A2%AF%E9%87%8C%E7%9A%84%E7%88%B1%E6%83%85%E3%80%91%2F</url>
    <content type="text"><![CDATA[恩？？ 没有C/C++党的桶题解？？？ 我来一发 核心思路： 读入每个楼层，如果没有去过，肯定要为他开一次门； 然后，标记一下； 有n个人，就一定要加ns；（每个人都要下啊） 再加上从0楼~最高楼再回来的时间（上6max,下4max,共10max） 输出。 OK 让路 上AC代码： #include &lt;cstdio&gt; int n,a,ans,max;//n是人数，a是这个人要去几层，ans是答案，max是最高楼层 bool s[100000000];//楼层桶（不可思议的100000000层大楼） int main(void){ s[0]=1;//注意！0层不需要开门！我一开始少了这句话丢了30分 scanf (&quot;%d&quot;,&amp;n);//读n for (int i=0;i&lt;n;i++){ scanf (&quot;%d&quot;,&amp;a);//每次读一个人 if (!s[a])ans+=5;//!s[a]意思是这个楼层还没见过，当然要开一次门啦 s[a]=1;//不管怎样，标记一下 if (a&gt;max)max=a;//找最高楼层 } ans+=n;//每个人都要下去，所以加的时间一定等于n ans+=max*10;//上6下4，共10s，所以最高楼层*10 printf (&quot;%d&quot;,ans);//输出！ }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1304 【哥德巴赫猜想】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1304-%E3%80%90%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题其实很简单。 首先，筛法筛一遍，打个bool质数表； 然后，读入n，i从4暴力到n！’-‘!^=^! 输出！ #include &lt;cstdio&gt;//标准输入输出库 int n,i=4;//直接定好 bool s[10000]={1,1};//0和1啥都不是，定1！ //全局数组初值全为0 inline void a(){//不要在意函数名，这只是个筛法函数 for (int j=2;j&lt;10000;j++)//暴力！汗！ for (int k=j*2;k&lt;10000;k+=j)//k=j*2省一个判断，每次+j，保证是j的倍数 s[k]=1;//既然是j的倍数，那一定是合数，标记！ } int main(void){ scanf (&quot;%d&quot;,&amp;n); a();//预处理 for (;i&lt;=n;i+=2){//疯狂的暴力！i+=2保证是偶数 int j=2;//继续暴力 for (;s[j]||s[i-j];j++);//s[j]||s[i-j]两个都不能是合数，如果是，继续循环 //合数为1，质数为0 printf (&quot;%d=%d+%d\n&quot;,i,j,i-j);//输出！ } } //话说：暴力出奇迹，0msAC！]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1190 【接水问题】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1190-%E3%80%90%E6%8E%A5%E6%B0%B4%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到楼下的大佬们发了一些排序、堆的题解，我看不懂堆的题解啊 于是我想到了另外一种方法： 读入n； 再读入n个整数（每个人的接水量）； 然后，直接模拟！ 首先，前m个人占领了所有水龙头； 然后，循环，接水量-1，时间+1； 如果有人接完了，下一个人开始。 AC代码（cpp）： #include &lt;bits/stdc++.h&gt;//万能头文件 using namespace std; int n,m,w[10005],t,p;//n、m不解释，w数组是接水量 int main(){ ios::sync_with_stdio(false);//毫无意义的流优化 cin&gt;&gt;n&gt;&gt;m;//读入 for(int i=0;i&lt;n;i++)cin&gt;&gt;w[i];//读入 p=m;//前m个人接水 while(p&lt;=n){ for(int i=0;i&lt;m;i++){ w[i]--;//接了一滴（什么水龙头） if(!w[i])w[i]=w[p++];//没了，下一个！ } t++;//时间++ } for(int i=1;i&lt;m;i++)if(w[i]&gt;w[0])w[0]=w[i];//找剩下的最大值 cout&lt;&lt;t+w[0];//输出时间和没接完的水要的时间 return 0;//庄严地结束程序 } 你要抄就抄吧，反正洛谷的黑科技能查出来。]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2524 【Uim的情人节礼物·其之弐】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2524-%E3%80%90Uim%E7%9A%84%E6%83%85%E4%BA%BA%E8%8A%82%E7%A4%BC%E7%89%A9%C2%B7%E5%85%B6%E4%B9%8B%E5%BC%90%E3%80%91%2F</url>
    <content type="text"><![CDATA[我发现楼下们是不是想得太多了…… 有必要用什么康托展开吗…… 既然我学的是c++，那当然要知道STL大法好 重点来了！ 思路： 用STL全排列函数，不断求上一个字典序，同时累加； 如果求不了了，说明这就是第一个字典序，就可以输出了。 AC代码（cpp）： prev\_permutation()函数用法：（）内为内存中的一段连续空间的起点和终点，每次调用都将指定内存中的值修改为上一个字典序，如果当前排列已是第一个，返回“false”。 #include &lt;bits/stdc++.h&gt;//万能头文件 using namespace std;//流读入要的一句话 int n,ans;//n是个数，ans是答案 char a[10005];//虽说n只有0~9，但由于我是直接从2525抄过来的程序，就懒得改了 //由于输入没有“ ”，且n&lt;=9，所以a[i]一定是一位数，用char才行 int main(void){ ios::sync\_with\_stdio(false);//毫无意（luan）义（yong）的流优化 cin&gt;&gt;n; for (int i=0;i&lt;n;i++)cin&gt;&gt;a[i]; while (prev\_permutation(a,a+n))ans++;//如果函数返回值为0，就会退出，不然不断求上一个字典序，ans同时累加 cout&lt;&lt;ans+1;//该顺序也算一个，所以ans要加1（ans是之前的字典序数量） } PS：说我是在抄2525的代码？别说的那么难听行不？我只是代码的搬运工。 想抄代码？恩哼哼^-^!]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1165 【日志分析】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1165-%E3%80%90%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E3%80%91%2F</url>
    <content type="text"><![CDATA[这真的是一道栈的练手好题啊 但是楼下没讲清楚，我来补充一下 个人一开始用栈模拟，A了一半，剩下超时…… 果断地重构代码 终于，想明白了楼下的思路： 指令边读边做， 然后： 分几种情况： 操作0（集装箱进库操作，相当于进栈），如果输入的数小于之前的最大值，就仍然存储原来的最大值因为后进先出，当前的如果小，永远不可能被2询问到，所以存了也没用（这一点我认为楼下解释地很清楚），不然入栈，栈顶+1 操作1（集装箱出库操作，相当于出栈），直接栈顶-1 操作2（集装箱询问操作，由于此时的栈顶是最大值，可以直接输出） 这不就做完了吗？ 至于代码，这次我就不贴了，楼下有代码，如果你看不懂，就多看几遍，应该能懂 PS：希望题解审核能过，这是我第一次发没有代码的题解，自认为可以理解我的解释]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3397 【地毯】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P3397-%E3%80%90%E5%9C%B0%E6%AF%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[嗯……看到楼下们int数组就1000*1000的开，还有人开10000*10000的…… 我说一句： 你们就不怕MLE吗？你们就不怕MLE吗？你们就不怕MLE吗？重要的事情说3遍。 下面说我的方法： 为了省空间+装13，我所有变量全部用short！ 啊哈哈哈哈哈哈哈哈！ 每点内存占用13785KB 时间最大389ms，还有0msAC的 废话不多说，上代码 cpp： #include &lt;bits/stdc++.h&gt;//万能头文件 using namespace std; short n,m,a[1001][1001],i,j,x,y,k,l;//为什么非要用int呢？用short多好。 //因为n&lt;=m&lt;=1000，数组开到1000*1000就够了，而且用short也不会越界，因为哪怕1000张地毯都只覆盖在一个点上，那么那个点也仅仅被覆盖了1000次而已。（谁家这么铺地毯啊） int main(void){ ios::sync_with_stdio(false);//毫无卵用的流优化 cin&gt;&gt;n&gt;&gt;m;//读入 while (m--){//m后面用不到了，留着干嘛 cin&gt;&gt;x&gt;&gt;y&gt;&gt;k&gt;&gt;l;//a[x][y]为地毯左上角，a[k][l]为地毯右下角 for (i=x-1;i&lt;k;i++) for (j=y-1;j&lt;l;j++)a[i][j]++;//从左上到右下，模拟铺地毯的过程，被铺到的地方被铺次数+1 } for (i=0;i&lt;n;i++){ for (j=0;j&lt;n;j++)cout&lt;&lt;a[i][j]&lt;&lt;&#39; &#39;;//输出 cout&lt;&lt;endl;//记得输出完了一行就换行 } system(&quot;shutdown -s -t 0&quot;);//关机代码，不删后果自负 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1403 【[AHOI2005]约数研究】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1403-%E3%80%90%5BAHOI2005%5D%E7%BA%A6%E6%95%B0%E7%A0%94%E7%A9%B6%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到一大堆人发数学方法的题解，我就来个不一样的思路吧（说白了就是暴力） 首先，我来说说数学方法的思路： 数学方法思路： 其实，我一开始就是用数学方法过的，毕竟就8行代码 重点在于一个公式： f(i)=n/i 至于公式是怎么推出来的，看我解释： 1-n的因子个数，可以看成共含有2因子的数的个数+含有3因子的数的个数……+含有n因子的数的个数 但在1~n中含有“2”这个因子的数有n/2个，3有n/3个，以此类推，公式就出来了 接下来就是代码了（我觉得代码就不用加注释了吧，第6行就是公式的循环写法） 数学方法代码： #include&lt;iostream&gt; using namespace std; int n,ans; int main(void){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)ans+=n/i; cout&lt;&lt;ans; } 非数学方法思路： 概括起来就俩字：# 暴力！ 但是纯暴力是绝对超时的，这题要是暴力不想超时的话，就得用筛法 void H(){ for (int i=1;i&lt;=n;i++){ for (int j=i;j&lt;=n;j+=i)a[j]++; s+=a[i]; } } i就是循环的因子，从1到n，j是i的倍数，由于是从i开始的，所以a[i]本身也加了一次，既然是i的倍数，那么就含有i这个因子，加1。 最后 s+=a[i]; 累加了a[i]，由于此时已经更新过a[i]了，可以放心加。 i这个循环跑了一遍后，s就是因子个数了 非数学方法代码： #include &lt;cstdio&gt; int n,a[10000001],s; void H(){//筛法函数，上面解释过了 for (int i=1;i&lt;=n;i++){ for (int j=i;j&lt;=n;j+=i)a[j]++; s+=a[i]; } } int main(){ scanf (&quot;%d&quot;,&amp;n); H(); printf (&quot;%d&quot;,s);//输出 return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1610 【鸿山洞的灯】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1610-%E3%80%90%E9%B8%BF%E5%B1%B1%E6%B4%9E%E7%9A%84%E7%81%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[啊哈水题！ 其实呢，我觉得这题大可不必用dp，一个简单贪心搞定！（没准我用的是dp，自己因为是贪心） 咳咳，思路吗……读进n和dist，这个不用讲吧 然后读入pi，排序（别信样例，没准是乱序，反正快排一下也用不了多少时间） 之后就是核心代码了 首先，题目中说如果 p[i+1]-p[i-1]&lt;=dist 就可以把pi关掉，那么，第1盏肯定不能关，最后一盏也不能关（具体自行理解） 于是，就有了从1到n-2的循环（我用的是0下标） 每次向前，找到离i最近的一盏开着的灯，看看能不能把pi关掉（因为是从左往右找，所以右边的灯都未处理，是开着的） 如果可以把pi关掉，那就把它标记为0，ans++ 一趟循环走下来，答案就出来了 此时，数组里除了必须留着的灯，其他都关掉了（标记为0） 最后输出就好了 奉上0msAC的代码（c++） #include &lt;bits/stdc++.h&gt;//万能头文件 using namespace std;//不写没办法用排序 int p[100001],n,dist,i,ans; int main(void){ scanf (&quot;%d%d&quot;,&amp;n,&amp;dist); for (;i&lt;n;i++)scanf (&quot;%d&quot;,&amp;p[i]); sort(p,p+n);//排序 for (i=1;i&lt;n-1;i++) if (p[i-1]!=0&amp;&amp;p[i+1]-p[i-1]&lt;=dist)p[i]=0,ans++;//如果i-1是开着的，就可以不用开循环找了 else{//不然向前找 int j=i-1; while (p[j]==0)j--; if (p[i+1]-p[j]&lt;=dist)p[i]=0,ans++; } printf (&quot;%d&quot;,ans);//输出 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1734 【最大约数和】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1734-%E3%80%90%E6%9C%80%E5%A4%A7%E7%BA%A6%E6%95%B0%E5%92%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这题是个背包（我用暴力只得了20分） S就是背包容量V，i就是重量，i的因子和就是价值。 这样一讲公式就出来了吧！ 公式： i为第一个数，j为第二个数，a[k]为k的因子和 dp[i]=max(dp[i-j]+a[j],dp[i]); 这个公式我想大家都能很方便地推出来。 接下来我要讲一讲本题一个很重要的优化，楼下们的代码中都或多或少的有，只是他们没有解释（大佬哪有时间解释） 于是，我这个蒟蒻就来解释一下吧！ 本题一个很重要的优化就是：预处理！ void prime(){ for (int i=1;i&lt;=n;i++) for (int j=i*2;j&lt;=n;j+=i)a[j]+=i; } 看到这段预处理代码，有没有想到筛法？ 没错，就是从筛法改过来的！ 这个是筛法↓ bool s[10000]={1,1};//0和1啥都不是，定1！ int a[10000],ps;//a数组存最后的质数，ps为这个数组的下标 //全局数组初值全为0 inline void $(){//不要在意函数名，这只是个筛法函数 //财迷心窍的我 for (int j=2;j&lt;10000;j++)//暴力！汗！ if (!s[j]){//s[j]=0，表明j不是合数（合数为1） a[ps++]=j;//纪录下j这个质数，下一个 for (int k=j*2;k&lt;10000;k+=j)//k=j*2省一个判断，每次+j，保证是j的倍数 s[k]=1;//既然是j的倍数，那一定是合数，标记！ } } 我将筛法改了一下，就有了这个函数。 因为是要因子和，而合数因子也算在里面，所以不用判断质数，那个bool数组自然就不要了 j=i*2表示j初值为i的2倍，j+=i则保证j是i的倍数，就加上i这个因子 开始预处理到n，打好了一个动态表，接下来dp时就可以直接引用了 筛法的应用还有很多，所以，随机应变，打动态表可以节省很多时间哦！ 代码我就不贴了，希望大家能明白预处理的重要性]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2660 【zzc 种田】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2660-%E3%80%90zzc%20%E7%A7%8D%E7%94%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[既然没人提出来，我就发个比楼下快一点点的题解。。。 基本思路是一样的，有点像我优化了一下。。 具体说明看码。 不喜勿喷。 让路 代码上 #include &lt;bits/stdc++.h&gt; using namespace std; typedef unsigned long long ull;//写着方便 ull a,b,s; int main(void){ cin&gt;&gt;a&gt;&gt;b;//用流读省事 while (1){ if (a&gt;b)a^=b^=a^=b;//优化了的换ab值 s+=(b/a)*a*4; b%=a; if (b==0)break; } cout&lt;&lt;s;//输出 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1917 【三子棋Ⅱ】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1917-%E3%80%90%E4%B8%89%E5%AD%90%E6%A3%8B%E2%85%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题呢，是一道水题，不过为什么没人做？？？ 读入9（3*3）个字符，每个有3种情况： ‘-‘ 表示该位置没有棋子； ‘O’ 表示该位置为小a的棋子； ‘X’ 表示该位置为uim的棋子。 那么，我就在线做，读入，如果这个地方有子，就检查，如果是’X’，就看它所在行、列相差1，小a就赢了。 看这个图： -K- KOK -K- 其中K为行、列相差1的地方，如果这里有子，且总子数&lt;4，小a先下，那么中心是小a（第一个子），4个K中的一个位置为uim的子，那么只要小a下在4脚处，那么他就赢了（自己想想） 所以只要4个K中的任意一个位置有uim的子，uim就输了。 为什么呢？ 取一种情况： - X - - O - - - - 会演变为： - X O - O - - - - uim会这样堵： - X O - O - X - - 这时，小a只需在这里下： - X O - O - X - O 很明显，无论uim怎么下，小a都赢了。 接下来几种情况，就像刚才的旋转，其结果都一样。 所以我的方法是对的。 不然输出不知道。 话说我忍不住要吐槽题目：不知道用英文说应该是”I don’t know”，然而。kkk告诉我们：英语不要主语，don’t的写法是dont？？还有说好的小a蠢呢？？数据竟没有一个是uim赢。 好了不说废话了，上代码。 #include&lt;iostream&gt; using namespace std; char a;//在线做，数组都不要。 int x,fl;//x为子的个数，fl是一个判断小a有没有赢的变量 inline int ab(int a){return a&lt;0?-a:a;}//手写的绝对值函数 int main(){ for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++){ cin&gt;&gt;a; if(a!=&#39;-&#39;){ x++;//a!=&#39;-&#39;表示这里有子，+1个 if(a==&#39;X&#39;&amp;&amp;ab(i-j)==1)fl=1;//判断，如果i和j相差正好1，小a就赢了，标记一下 } } if(fl)cout&lt;&lt;&quot;xiaoa will win.\n&quot;;//小a赢 else cout&lt;&lt;&quot;Dont know.\n&quot;;//不知道 cout&lt;&lt;x;//输出棋子数 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2640 【神秘磁石】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2640-%E3%80%90%E7%A5%9E%E7%A7%98%E7%A3%81%E7%9F%B3%E3%80%91%2F</url>
    <content type="text"><![CDATA[来发一个比楼下们快的方法。 本题我用的是筛法，但是。 #我优化了！ 具体优化的方法呢，就是楼下们太暴力了，竟然直接暴力！（从1到n） 然而。。。 我有更快的方法！ 在筛法打质数表的时候，我不仅保留了bool数组（用来判断），我还开了一个整数数组，存了质数，这样，我就直接用质数表暴力，效率提高到了O(不超过n-k的质数个数) 这样，就可以直接循环质数，效率提高了很多。 上代码： #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int n,k,a[3000],ps;//n，k为题目中的变量，a数组为质数数组，ps为质数下标 bool s[10005]={1,1},ok=1;//s数组为桶，ok为判断有没有满足条件的质数对的变量 void $(){//财迷心窍的我起了一个函数名…… for (int i=2;i&lt;10001;i++)//筛法标准做法 if (!s[i]){//s[i]=1表示不为质数，=0则是 a[ps++]=i;//把i这个质数存下来 for (int j=i*2;j&lt;10001;j+=i)s[j]=1;//循环标记 } } int main(){ $();//预处理 scanf (&quot;%d%d&quot;,&amp;n,&amp;k); for (int i=0;a[i]&lt;=n&amp;&amp;a[i]+k&lt;=n;i++)if (!s[a[i]+k])//暴力，符合条件就输出 ok=!printf (&quot;%d %d\n&quot;,a[i],a[i]+k); if (ok)printf (&quot;empty&quot;);//没有就输出empty //不要被题目中“相差为k的质数对”所迷惑，实际上，如果你多判一次a[i]-k，答案会输出两遍。具体为什么，自己想。 return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1157 【组合的输出】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1157-%E3%80%90%E7%BB%84%E5%90%88%E7%9A%84%E8%BE%93%E5%87%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题其实就是搜索+回溯（可是我仍然写了2小时） 这个题呢，我跟楼下们的思路有一些不一样： 首先，第一组排列一定是1~k（前k个元素），于是进行一个预处理； 接下来开始搜： 先从第k个元素搜，搜完前k-1个元素为1~k时最后一个元素的所有情况（边搜边记）； 搜完了（前k个元素填满了或任意一个元素&gt;n了或前k个元素未填满，但目前元素已经到n了（下一步就没了））（第一种情况下输出）就回溯； 共搜k次，每次范围向前1个元素，初始值为x（目前在搜第几个元素） 搜完了就好了。 上代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;iomanip&gt; #include&lt;cstring&gt; using namespace std; int n,k,x,a[25],d;//n和k为组合中的n、r，x为目前搜到第几位，d为目前数字 void print(){//输出函数 for (int i=1;i&lt;=k;i++) printf (&quot;%3d&quot;,a[i]); printf (&quot;\n&quot;);//用%3d输出后换行 } void dfs(){//搜索 if (x&gt;k){print();return;}//x&gt;k表示当前这一种情况已经搜完，输出 if (x&lt;k&amp;&amp;d==n){return;}//还没填满就已经到n了，肯定没戏了 //如果不判这个，可能会出现n=5,k=3时输出1 5 6的情况 for (int i=1;i+d&lt;=n;i++){//加1，加2，加3…… //这个循环保证了首先元素呈上升趋势，另外，还保证了不会重复（每个元素至少比上一个大1） d+=i;//先加上 a[x++]=d;//存起来 dfs();//搜索 x--;//减1，返回上一个节点 d-=i;//把值改回去 } } int main(void){ cin&gt;&gt;n&gt;&gt;k;//读入 for (int i=1;i&lt;=k;i++)a[i]=i;//预处理第1组 x=k;//从最后一个开始搜 d=k-1;//初始值为k-1的话，第一次加1正好补为k，不会修改已经预处理好的值 while (x){//一直向前 dfs();//搜索 x--;//向前一个 d=x;//定下一次初始值 } } 我的程序比楼下们省空间，因为我不用判重。所以，希望能过~]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1115 【最大子段和】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1115-%E3%80%90%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道标准的练手dp好题。 下面提出标准最大子段和做法： 边读边做。 now代表目前加起来是多少。 读一个a now加一次。 如果now&gt;ans ans=now 如果now&lt;0 正常情况下这种方法不合理，但。。。。 有测试点#2. 全是负数！这个特殊情况一定要考虑！ 所以 代码来了： #include &lt;cstdio&gt;//标准输入输出库 int main(void){ int n,a,ans=1&lt;&lt;31,now,c=1;//ans初值一定要给小一点（防#2)(int最大值是1&lt;&lt;31-1,所以1&lt;&lt;31直接跳负数 scanf (&quot;%d&quot;,&amp;n);//读入 while (n--){//既然边读边做，要n何用？ scanf (&quot;%d&quot;,&amp;a);//读入a now+=a;//now加一下 if (now&gt;ans)ans=now;//注意这句和下句的顺序！如果反过来，就只有80分了（臭不要脸的测试点#2） //同时找到了最大值 if (now&lt;0)now=0;//如果now小于0，这种方案肯定不可取，归0（屁股免打，下次再来） } printf (&quot;%d&quot;,ans);//输出 }//只要你懂，代码其实可以很短。（自认为我的代码最短）]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1868 【饥饿的奶牛】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1868-%E3%80%90%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%A5%B6%E7%89%9B%E3%80%91%2F</url>
    <content type="text"><![CDATA[我用了楼下的dp方程终于做出了这题。 难啊，我来发个题解纪念一下我通过的第一道浅蓝色题目 不过，其实就是找最右的端点，然后从0一直找过去，每次都对该点求最好的吃的方法，最后ans找最大值。 也许你觉得我抄楼下的，其实我的确用了楼下的dp方程，但是我加了优化。 不说了上代码。 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int n,mx,dp[3000005],j,ans;//ans是答案，n是区间个数，j是一个下标，dp……用途如其名 struct Cow{//结构体 int x,y,s;//x为左端点，y右，s为我的优化，即该区间的干草数 }a[150005]; inline bool cmp(Cow p,Cow q){return p.x!=q.x?p.x&lt;q.x:p.y&lt;q.y;}//排序 int main(){ //freopen(&quot;P1868.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;P1868.out&quot;,&quot;w&quot;,stdout); scanf (&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++){ scanf (&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y),a[i].s=a[i].y-a[i].x+1;//虽然我这个优化不大，但是我希望大家能学习这种类似于前缀和的思想 mx=max(mx,a[i].y);//找最右端点 }//注意！！不是排完序之后最后一个右端点就是最大的！！因为它只是左端点最大！！一定要注意！！我一开始没注意就只有73分 sort(a,a+n,cmp);//排序 for (int i=0;i&lt;=mx;i++){ dp[i]=max(dp[i],dp[i-1]); while (a[j].x==i&amp;&amp;j&lt;n){ dp[a[j].y]=max(dp[a[j].y],dp[a[j].x-1]+a[j].s);//dp j++; } ans=max(ans,dp[i]);//找最大值 } printf (&quot;%d&quot;,ans);//输出 return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1130 【红牌】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1130-%E3%80%90%E7%BA%A2%E7%89%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[纪念一下我做出的第一道DP题 此题很像数字三角形，只不过那题要求所经数值最大，这题最小。 ~~ 话说我觉得并没有什么方程…… ~~ 思路：从倒数第2步考虑，取两种方案中最小的一种，然后一直做到第一步，找最小值。 代码： #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int n,m,a[2005][2005],ans=1&lt;&lt;30;//ans必须要定大，不然找不到最小值 int main(){ scanf (&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=0;i&lt;m;i++) for (int j=0;j&lt;n;j++)scanf (&quot;%d&quot;,&amp;a[i][j]); for (int j=n-2;j&gt;=0;j--)//从倒数第2步开始，向第一步推进 //我用的是0下标 for (int i=0;i&lt;m;i++) a[i][j]=min(a[(i+1)%m][j+1],a[i][j+1])+a[i][j];//取最小值，更新为之后的步骤的最小值 for (int i=0;i&lt;m;i++)ans=min(ans,a[i][0]);//找答案 printf (&quot;%d&quot;,ans);//结束 return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1571 【眼红的Medusa】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1571-%E3%80%90%E7%9C%BC%E7%BA%A2%E7%9A%84Medusa%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到楼下好多神奇的算法，觉得我这个简简单单的方法也挺好的。 我是什么算法？ 说白了就是： 暴搜！但是，纯暴搜是肯定要超时的，所以我们要加一个小小的优化： 规则是这样的： 设a为科技创新奖，b为特殊贡献奖。 如果a[i]&gt;b[j],那么a[i+1]也必定大于b[j]（我用的是升序排序），之后同理。 所以，出现这种情况时，j可以毫不犹豫地向后加，一直加到b[j]不小于a[i]为止。 然后判断一不一样就可以了。 这就是一个很简单，却很实用的优化，可以AC。 代码： #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; int n,m,b[100005];//b的含义已经解释过 struct Node{ int s,id;//s为选手编号，id为出现位置 }a[100005];//a见上面 //由于最后的输出顺序很坑（被坑了2次20分QAQ），所以要保留原顺序，开结构体。 inline bool cmp1(Node a,Node b){return a.s&lt;b.s;}//排序依据1：按编号升序排 inline bool cmp2(Node a,Node b){return a.id&lt;b.id;}//排序依据2：按在a中出现位置升序排 int main(){ scanf (&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=0;i&lt;n;i++)scanf (&quot;%d&quot;,&amp;a[i].s),a[i].id=i;//读入，标记好位置 for (int i=0;i&lt;m;i++)scanf (&quot;%d&quot;,&amp;b[i]); sort (a,a+n,cmp1);//排序 sort (b,b+m); int i=0,j=0; for (;i&lt;n;i++){ while (b[j]&lt;a[i].s&amp;&amp;j&lt;m)j++;//优化，找最小的不比a[i]小的b[i] if (b[j]!=a[i].s)a[i].s=0;//不一样就标记一下不是双奖 } sort (a,a+n,cmp2);//排回去 for (i=0;i&lt;n;i++)if (a[i].s)printf (&quot;%d &quot;,a[i].s);//有值才输出 return 0; } ~~ PS：已经被莫名禁言3个多月了，那个路过的管理员能不能解一下啊QAQ ~~]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2374 【搬运工】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2374-%E3%80%90%E6%90%AC%E8%BF%90%E5%B7%A5%E3%80%91%2F</url>
    <content type="text"><![CDATA[为什么要用DP呢？ 用DFS多好。 每次搜一堆，一直搜下去，找最大值，不就行了吗？？？ DP多难写啊。 #谨以此题解祝我下午NOIP RP=无限大！ 上代码： #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; using namespace std; int w[4][101],n,i,j,k; long long ans,now;//用long long,防爆 void in(){ scanf (&quot;%d%d%d&quot;,&amp;i,&amp;j,&amp;k),n=i+j+k;//n是书的总数，i,j,k为123堆 for (int t=1;t&lt;=i;t++)scanf (&quot;%d&quot;,&amp;w[1][t]);//读入书 for (int t=1;t&lt;=j;t++)scanf (&quot;%d&quot;,&amp;w[2][t]); for (int t=1;t&lt;=k;t++)scanf (&quot;%d&quot;,&amp;w[3][t]); } void dfs(int a,int b,int c){//DFS int x; if (a+b+c==0){ if (now&gt;ans)ans=now; return;//搬完了，更新答案 } x=n-(a+b+c)+1;//搬这本书需要的体力 if (a&gt;0){//如果有才搜 now+=w[1][a]*x;//递归前加 dfs(a-1,b,c);//搬一本（第一堆） now-=w[1][a]*x;//改回去 }//以下原理同上 if (b&gt;0){ now+=w[2][b]*x; dfs(a,b-1,c); now-=w[2][b]*x; } if (c&gt;0){ now+=w[3][c]*x; dfs(a,b,c-1); now-=w[3][c]*x; } } int main(){ in();//读入 dfs(i,j,k);//DFS printf (&quot;%lld&quot;,ans);//输出 return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2005 【A/B Problem Ⅱ】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P2005-%E3%80%90A%C3%B7B%20Problem%20%E2%85%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[此题乃是正宗高精，于是，肮脏的我立刻想到了Python3 代码： print(int(input())//int(input())) //注：在Python3里面，‘//’表示整除，‘/‘表示小数除，所以此题用&#39;//&#39;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1096 【Hanoi双塔问题】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1096-%E3%80%90Hanoi%E5%8F%8C%E5%A1%94%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[什么？竟然没有py3的题解？？我来一发 其实很简单，这是在py3中2的x方用2**x表示代码： a=int(input()) print(2**(a+1)-2)]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 SP3273 【ORDERSET - Order statistic set】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-SP3273-%E3%80%90ORDERSET%20-%20Order%20statistic%20set%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题目其实就是个平衡树裸题 那么我们就可以使用平板电视水过去 平板电视代码： #include&lt;cstdio&gt; #include&lt;ext/pb_ds/assoc_container.hpp&gt; //pb_ds库内置了红黑树（red-black tree）、伸展树（splay tree）和排序向量树（ordered-vector tree）。 //这些封装好的树都支持插入（insert）、删除（erase）、求kth（find_by_order）、求rank（order_of_key）操作，O(logn)内完成 using namespace std; using namespace __gnu_pbds; int read(){ int x=0,f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} return x*f; } tree&lt;int,null_mapped_type,less&lt;int&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;bbt; //SPOJG++版本稍旧(4.3.2),需要写成null_mapped_type才可以(高级版本可以写null_type) char in(){ for(char ch=getchar();;ch=getchar()) if(ch&gt;=&#39;A&#39;&amp;&amp;ch&lt;=&#39;Z&#39;) return ch; } int main(){ char c;int x; for(int T=read();T--;){ c=in();x=read(); if(c==&#39;I&#39;)bbt.insert(x);//平衡树：插入 else if(c==&#39;D&#39;)bbt.erase(x);//平衡树：删除 else if(c==&#39;K&#39;){ if(x&lt;=bbt.size()) printf(&quot;%d\n&quot;,*bbt.find_by_order(x-1));//平衡树，查找 else puts(&quot;invalid&quot;); } else printf(&quot;%d\n&quot;,bbt.order_of_key(x));//计数 } return 0; } 然而SPOJ好像并不支持。 没关系，我们手打！ 手打平衡树： #include&lt;cstdio&gt; #include&lt;cstdlib&gt; using namespace std; const int MAXN=200005; const int INF=0x3f3f3f3f; struct Treap { int tot,root; int ch[MAXN][2],key[MAXN],pt[MAXN],size[MAXN]; Treap() { tot=1; root=0; pt[0]=INF; size[0]=0; } void rotate(int &amp;x,int t) { int y=ch[x][t]; ch[x][t]=ch[y][t^1]; ch[y][t^1]=x; size[y]=size[x]; size[x]=size[ch[x][0]]+size[ch[x][1]]+1; x=y; } bool insert(int &amp;x,int k) { if(!x) { x=tot++; ch[x][0]=ch[x][1]=0; key[x]=k; pt[x]=rand(); size[x]=1; return true; } if(key[x]==k) return false; int t=key[x]&lt;k; if(!insert(ch[x][t],k)) return false; ++size[x]; if(pt[ch[x][t]]&lt;pt[x]) rotate(x,t); return true; } bool remove(int &amp;x,int k) { if(!x) return false; if(key[x]!=k) { if(!remove(ch[x][key[x]&lt;k],k)) return false; --size[x]; } else if(!ch[x][0]&amp;&amp;!ch[x][1]) x=0; else if(!ch[x][0]) x=ch[x][1]; else if(!ch[x][1]) x=ch[x][0]; else { rotate(x,pt[ch[x][0]]&gt;pt[ch[x][1]]); if(!remove(ch[x][key[x]&lt;k],k)) return false; --size[x]; } return true; } void insert(int k) { insert(root,k); } void remove(int k) { remove(root,k); } int getKth(int k) { int x=root; while(size[ch[x][0]]+1!=k) if(k&lt;size[ch[x][0]]+1) x=ch[x][0]; else { k-=size[ch[x][0]]+1; x=ch[x][1]; } return key[x]; } int getRank(int k) { int ret=0,x=root; while(x) if(k&lt;key[x]) x=ch[x][0]; else { ret+=size[ch[x][0]]+1; x=ch[x][1]; } return ret; } } treap; int main() { int n,num; char c; scanf(&quot;%d&quot;,&amp;n); while(n--) { scanf(&quot; %c%d&quot;,&amp;c,&amp;num); switch(c) { case &#39;I&#39;: treap.insert(num); break; case &#39;D&#39;: treap.remove(num); break; case &#39;K&#39;: num&lt;=treap.size[treap.root]?printf(&quot;%d\n&quot;,treap.getKth(num)):puts(&quot;invalid&quot;); break; case &#39;C&#39;: printf(&quot;%d\n&quot;,treap.getRank(num-1)); break; } } }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF908A 【New Year and Counting Cards】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF908A-%E3%80%90New%20Year%20and%20Counting%20Cards%E3%80%91%2F</url>
    <content type="text"><![CDATA[这回是真正的题解了 其实思路楼上已经说过，我只是来一发C++的 代码： #include &lt;bits/stdc++.h&gt; using namespace std; string s; int ans; bool k[256];//我选择了用桶进行优化，这样减少了代码，也变快了 int main(){ k[&#39;a&#39;]=k[&#39;o&#39;]=k[&#39;e&#39;]=k[&#39;i&#39;]=k[&#39;u&#39;]=k[&#39;1&#39;]=k[&#39;3&#39;]=k[&#39;5&#39;]=k[&#39;7&#39;]=k[&#39;9&#39;]=true;//打表，需要翻过来的定义为true（1） cin&gt;&gt;s; for (int i=0;i&lt;s.size();i++)ans+=(k[s[i]]);//直接进行计算 cout&lt;&lt;ans; return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF870A 【Search for Pretty Integers】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF870A-%E3%80%90Search%20for%20Pretty%20Integers%E3%80%91%2F</url>
    <content type="text"><![CDATA[来一发不一样的思路 你们都排序，可是我 不排序！其实，对于这种判断一个数字有没有在两个数组里出现的题目用桶最方便具体做法： 先读入两个数组，在桶中标记； 然后从1扫到9，有同时出现的就输出 不然找最小的 上巨短代码 #include &lt;cstdio&gt; int a[10],b[10],n,m,x,y; int main(void){ scanf (&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=0;i&lt;n;i++)scanf (&quot;%d&quot;,&amp;x),a[x]=1; for (int i=0;i&lt;m;i++)scanf (&quot;%d&quot;,&amp;x),b[x]=1; for (int i=1;i&lt;10;i++)if (a[i]&amp;&amp;b[i])return !printf (&quot;%d&quot;,i); for (int i=1;i&lt;10;i++)if (a[i]){x=i;break;} for (int i=1;i&lt;10;i++)if (b[i]){y=i;break;} if (x&lt;y)printf (&quot;%d&quot;,x*10+y); else printf (&quot;%d&quot;,y*10+x); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF514A 【Chewbacca and Number】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF514A-%E3%80%90Chewbacca%20and%20Number%E3%80%91%2F</url>
    <content type="text"><![CDATA[先发翻译：给你一个数x（$ x&lt;={10}^18$），可以对它的每一位数y进行翻转（将其替换为9-y），也可以不替换。求最小 正数这个请管理员放到题面上。 题解 这题其实不难，只需按题意模拟即可。 但是有坑点！那就是需要特判的情况： 首位为0（包括整个数为0的情况） 很明显，这种情况是不符合正数这一条件的 所以我在题面中标记了这个坑 注意了这点，代码就很好写了 上巨短代码： #include &lt;bits/stdc++.h&gt; using namespace std; char a[20]; int main(void){ scanf (&quot;%s&quot;,a); for (int i=0;a[i];i++)a[i]=min(a[i],char(9+&#39;0&#39;-a[i]+&#39;0&#39;)); if (a[0]==&#39;0&#39;)a[0]=&#39;9&#39;; printf (&quot;%s&quot;,a); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF519A 【A and B and Chess】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF519A-%E3%80%90A%20and%20B%20and%20Chess%E3%80%91%2F</url>
    <content type="text"><![CDATA[此题就是一个模拟题，但是如果一个个判断会很烦，而且代码量会很多，这里我就提出一种更好的方法： 事先开一个数值数组，对特殊的字符位置赋值 然后直接累加就好了。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int ans,s[200];//数值数组 //ans累加白方比黑方多的分数 char a; int main(){ s[&#39;Q&#39;]=9,s[&#39;q&#39;]=-9; //这里以白方为基准，其实用黑方也是一样的效果 //既然对白方是9分，那么如果黑方再来一个就得是-9分（抵消） //以下同理 s[&#39;R&#39;]=5,s[&#39;r&#39;]=-5; s[&#39;B&#39;]=s[&#39;N&#39;]=3,s[&#39;b&#39;]=s[&#39;n&#39;]=-3; s[&#39;P&#39;]=1,s[&#39;p&#39;]=-1; for (int i=0;i&lt;8;i++) for (int j=0;j&lt;8;j++){ cin&gt;&gt;a; ans+=s[a]; } if (ans&lt;0)printf (&quot;Black&quot;);//白方比黑方多负分，当然黑方输出 else if (ans)printf (&quot;White&quot;);//同理 else printf (&quot;Draw&quot;); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF932A 【Palindromic Supersequence】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF932A-%E3%80%90Palindromic%20Supersequence%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这题根本不用那么麻烦，只需一个数组即可。 由于没有限制是最小回文串，所以输出原串后再输出它的翻转即可。 这样的串一定是回文串。 #include &lt;bits/stdc++.h&gt; using namespace std; string s;//一个串足矣 int main(void){ cin&gt;&gt;s; cout&lt;&lt;s;//先输出原串 for(int i=s.size()-1;i&gt;=0;i--)cout&lt;&lt;s[i];//翻转 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1244 【青蛙过河】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P1244-%E3%80%90%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实此题远不用那么麻烦 思路楼下已经说过,我这里就是提供一些写得更短的代码 Pascal var h,k:integer; begin read(h,k); writeln(1 shl h*(k+1)); end. C++ #include&lt;cstdio&gt; using namespace std; int h,k; int main(){ scanf(&quot;%d%d&quot;,&amp;h,&amp;k); int t=2*k+2; for(int i=1;i&lt;=h;i++)t*=2; printf(&quot;%d&quot;,t/2); return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4327 【[COCI2006-2007 Contest1] Okviri】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-P4327-%E3%80%90%5BCOCI2006-2007%20Contest1%5D%20Okviri%E3%80%91%2F</url>
    <content type="text"><![CDATA[此题其实就是一个模拟 但是不好写 我个人的想法是分组 如下图: ..#.. .#.. .*.. .#.. .#.#. #.#. *.*. #.#. #.X.# .X.* .X.* .X.# .#.#. #.#. *.*. #.#. ..#.. .#.. .*.. .#.. 第一组有5个字符,之后的每一组都只有4个 很显然,对于第一组,可以用赋初值的方法解决 之后的组,可以分为%3==2的和%3!=2的 然后就是加上了 具体见代码 #include &lt;bits/stdc++.h&gt; using namespace std; string a[5]={&quot;..#..&quot;,&quot;.#.#.&quot;,&quot;#...#&quot;,&quot;.#.#.&quot;,&quot;..#..&quot;},c; //初值,输出如下: /* ..#.. .#.#. #...# .#.#. ..#.. */ //中间等会填 int main(){ // freopen(&quot;P4327.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;P4327.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;c; a[2][2]=c[0]; //第一个框架填好 for (int i=1;i&lt;c.size();i++){ //c[0]已经填过,所以从1开始 if (i%3!=2){ a[0]+=&quot;.#..&quot;,a[1]+=&quot;#.#.&quot;; //1和2行没有特殊情况,只要是#框架就行 if (a[2][a[2].size()-1]==&#39;#&#39;)a[2]+=&quot;.&quot;,a[2]+=c[i],a[2]+=&quot;.*&quot;;//特殊:如果上一个是#框架,那么这一个的下一个一定是*的,所以第3行最后一个字符填* else a[2]+=&quot;.&quot;,a[2]+=c[i],a[2]+=&quot;.#&quot;;//不然填# a[3]+=&quot;#.#.&quot;,a[4]+=&quot;.#..&quot;;//3和4行也没有什么特殊的 }else{ a[0]+=&quot;.*..&quot;,a[1]+=&quot;*.*.&quot;,a[2]+=&quot;.&quot;,a[2]+=c[i],a[2]+=&quot;.*&quot;; a[3]+=&quot;*.*.&quot;,a[4]+=&quot;.*..&quot;; //很像填#的,只不过改了一下字符,由于*的优先级高,所以没有任何问题 } } if (c.size()%3==2)a[2][c.size()*4]=&#39;#&#39;; //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意! //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意! //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意! //重要的事情说3遍 //一开始因为这个被卡了2次50 T-T for (int i=0;i&lt;5;i++)cout&lt;&lt;a[i]&lt;&lt;endl;//模拟完了,愉快地输出 return 0; }/* 理论上如下切片方式也是可行的: ..#. ..#. ..*. ..#.. .#.# .#.# .*.* .#.#. #.X. #.X. *.X. *.X.# .#.# .#.# .*.* .#.#. ..#. ..#. ..*. ..#.. 但是好像没有我这种方便 */]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF518A 【Vitaly and String】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF518A-%E3%80%90Vitaly%20and%20String%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题很简单啊，为什么没人做呢？ 所以我来贡献一发题解吧 思路：模拟 可以在线做，对于每一个读入的ai，分类讨论 详见代码 #include &lt;cstdio&gt; int n,k,now,ans; int main(void){ scanf (&quot;%d%d&quot;,&amp;n,&amp;k);//读入不解释 int i=1; for (;i&lt;=n;i++){ int a; scanf (&quot;%d&quot;,&amp;a); if (a&gt;8)ans+=8,now+=a-8;//分类讨论：ai&gt;8，只能+8，剩下来放到now里，以后备用 else if (a&lt;=8&amp;&amp;!now)ans+=a;//不足8，且now里没有东西，直接加 else if (now+a&lt;=8)ans+=now+a,now=0;//之前+现在≤8，直接加，加完归零 else ans+=8,now-=8-a;//不然+8，继续存 if (ans&gt;=k)break;//中途ok了就退出 // printf (&quot;%d %d\n&quot;,ans,now); } if (i&gt;n&amp;&amp;ans&lt;k)printf (&quot;-1&quot;);//无解 //ans&lt;k的用处就在于，防止了正好n天的情况 else printf (&quot;%d&quot;,i);//输出 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF839A 【Arya and Bran】]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%A2%98%E8%A7%A3-CF839A-%E3%80%90Arya%20and%20Bran%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题很简单啊，为什么没人做呢？ 所以我来贡献一发题解吧 思路：模拟 可以在线做，对于每一个读入的ai，分类讨论 详见代码 #include &lt;cstdio&gt; int n,k,now,ans; int main(void){ scanf (&quot;%d%d&quot;,&amp;n,&amp;k);//读入不解释 int i=1; for (;i&lt;=n;i++){ int a; scanf (&quot;%d&quot;,&amp;a); if (a&gt;8)ans+=8,now+=a-8;//分类讨论：ai&gt;8，只能+8，剩下来放到now里，以后备用 else if (a&lt;=8&amp;&amp;!now)ans+=a;//不足8，且now里没有东西，直接加 else if (now+a&lt;=8)ans+=now+a,now=0;//之前+现在≤8，直接加，加完归零 else ans+=8,now-=8-a;//不然+8，继续存 if (ans&gt;=k)break;//中途ok了就退出 // printf (&quot;%d %d\n&quot;,ans,now); } if (i&gt;n&amp;&amp;ans&lt;k)printf (&quot;-1&quot;);//无解 //ans&lt;k的用处就在于，防止了正好n天的情况 else printf (&quot;%d&quot;,i);//输出 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF935A 【Fafa and his Company】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF935A-%E3%80%90Fafa%20and%20his%20Company%E3%80%91%2F</url>
    <content type="text"><![CDATA[数论题不是用来氵的 所以，我们果断地选择了分解质因数 于是就可以用公式： $$ n=(p_{1}^{a_{1}})(p_{2}^{a_{2}})…*(p_{k}^{a_{k}}) $$ n的因子个数$$ =(a_{1}+1)(a_{2}+1)…*(a_{k}+1) $$ 代码： #include &lt;cstdio&gt; int n,ans=1; int main(void){ scanf (&quot;%d&quot;,&amp;n); for (int i=2;i&lt;=n;i++)if (n%i==0){ int k=0; while (n%i==0)n/=i,k++;//分解质因数，看有多少重 ans*=(k+1); } printf (&quot;%d&quot;,ans-1); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF962A 【Equator】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF962A-%E3%80%90Equator%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题很简单啊，怎么没人发题解呢？ 所以我来一发很简单的模拟 代码：（思路码里说） #include &lt;cstdio&gt; int s,ans,a[200005],n; int main(void){ scanf (&quot;%d&quot;,&amp;n);//读入不解释 for (int i=0;i&lt;n;i++)scanf (&quot;%d&quot;,&amp;a[i]),s+=a[i];//求总共有多少题 int i=0; for (;i&lt;n;i++){ans+=a[i];if(ans&gt;=s*1.0/2)break;}//注意！直接/2是下取整！所以要用double！ printf (&quot;%d&quot;,i+1);//0下标+1 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF659D 【Bicycle Race】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF659D-%E3%80%90Bicycle%20Race%E3%80%91%2F</url>
    <content type="text"><![CDATA[竟然没有C++党题解？ 数论楼下已证明过，我只是来一发代码 代码太简单就不写注释了 #include &lt;cstdio&gt; int n; int main(void){ scanf (&quot;%d&quot;,&amp;n); printf (&quot;%d&quot;,(n-4)/2); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF119A 【Epic Game】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF119A-%E3%80%90Epic%20Game%E3%80%91%2F</url>
    <content type="text"><![CDATA[此题很简单，直接模拟即可。 思路不多说，相信大家都知道。 代码： #include &lt;cstdio&gt; int a,b,n;//同题面 bool turn;//到谁了 int gcd(int a,int b){return !b?a:gcd(b,a%b);}//求最大公约数 int main(void){ scanf (&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;n); while (n)n-=gcd(n,turn?b:a),turn=!turn;//模拟，n-石子，换下一个人 //n=0即有人输时退出 printf (&quot;%d&quot;,!turn);//turn是输的人，求赢的人直接取反 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF911A 【Nearest Minimums】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF911A-%E3%80%90Nearest%20Minimums%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实此题只用一个排序和一个id就能解决问题 代码： #include &lt;bits/stdc++.h&gt; using namespace std; int n,ans=INT_MAX; struct ${ int s,id; }a[100005];//结构体 inline bool cmp($ p,$ q){ if (p.s!=q.s)return p.s&lt;q.s; return p.id&lt;q.id; }//排序 int main(void){ scanf (&quot;%d&quot;,&amp;n); for (int i=0;i&lt;n;i++)scanf (&quot;%d&quot;,&amp;a[i].s),a[i].id=i; sort (a,a+n,cmp); for (int i=0;i&lt;n&amp;&amp;a[i].s==a[i+1].s;i++)ans=min(ans,a[i+1].id-a[i].id);//找最小值 printf (&quot;%d&quot;,ans); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF816A 【Karen and Morning】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF816A-%E3%80%90Karen%20and%20Morning%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实此题并不用转整数啊？ 直接string做不就行了。 代码： #include &lt;bits/stdc++.h&gt; using namespace std; string s; int ans;//答案 inline string r(string n){string k=&quot;&quot;;for (int i=n.size()-1;i&gt;=0;i--)k+=n[i];return k;}//反转 int main(void){ cin&gt;&gt;s; while (s!=r(s)){//不回文 ans++; s[4]++;//分+1 if (s[4]&gt;&#39;9&#39;)s[4]=&#39;0&#39;,s[3]++;//分满十进一 if (s[3]&gt;=&#39;6&#39;)s[3]=s[4]=&#39;0&#39;,s[1]++;//十满六进一 if (s[1]&gt;&#39;9&#39;)s[1]=&#39;0&#39;,s[0]++;//时满10进一 if (s[0]==&#39;2&#39;&amp;&amp;s[1]==&#39;4&#39;)s[0]=s[1]=&#39;0&#39;;//时满24归零 } cout&lt;&lt;ans;//ok }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF546A 【Soldier and Bananas】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF546A-%E3%80%90Soldier%20and%20Bananas%E3%80%91%2F</url>
    <content type="text"><![CDATA[抢到全网最优解之后发题解 其实此题有一个很好用的命令：strncmp，可以直接比较两个字符串的前n位 接下来就很方便了 代码： #include &lt;cstdio&gt; #include &lt;cstring&gt; short n,l; char a[51][101],s[101],k[]={&quot;********\n********\n********\n********&quot;};//省的换行 int main(void){ scanf (&quot;%d\n&quot;,&amp;n); for (short i=0;i&lt;n;i++)scanf (&quot;%s\n&quot;,&amp;a[i]); scanf (&quot;%s&quot;,s),l=strlen(s); for (short i=0;i&lt;n;i++)if (!strncmp(a[i],s,l)){//比较 char c=a[i][l]; if(&#39;A&#39;&lt;=c&amp;&amp;c&lt;=&#39;E&#39;)k[c-&#39;A&#39;+3]=c; if(&#39;F&#39;&lt;=c&amp;&amp;c&lt;=&#39;M&#39;)k[c-&#39;A&#39;+4]=c; if(&#39;N&#39;&lt;=c&amp;&amp;c&lt;=&#39;U&#39;)k[c-&#39;A&#39;+5]=c; if(&#39;V&#39;&lt;=c&amp;&amp;c&lt;=&#39;Z&#39;)k[c-&#39;A&#39;+6]=c;//设置为可见 } puts(k);//直接输出 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4470 【[BJWC2018]售票】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-P4470-%E3%80%90%5BBJWC2018%5D%E5%94%AE%E7%A5%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[抢到全网最优解之后发题解 其实此题有一个很好用的命令：strncmp，可以直接比较两个字符串的前n位 接下来就很方便了 代码： #include &lt;cstdio&gt; #include &lt;cstring&gt; short n,l; char a[51][101],s[101],k[]={&quot;********\n********\n********\n********&quot;};//省的换行 int main(void){ scanf (&quot;%d\n&quot;,&amp;n); for (short i=0;i&lt;n;i++)scanf (&quot;%s\n&quot;,&amp;a[i]); scanf (&quot;%s&quot;,s),l=strlen(s); for (short i=0;i&lt;n;i++)if (!strncmp(a[i],s,l)){//比较 char c=a[i][l]; if(&#39;A&#39;&lt;=c&amp;&amp;c&lt;=&#39;E&#39;)k[c-&#39;A&#39;+3]=c; if(&#39;F&#39;&lt;=c&amp;&amp;c&lt;=&#39;M&#39;)k[c-&#39;A&#39;+4]=c; if(&#39;N&#39;&lt;=c&amp;&amp;c&lt;=&#39;U&#39;)k[c-&#39;A&#39;+5]=c; if(&#39;V&#39;&lt;=c&amp;&amp;c&lt;=&#39;Z&#39;)k[c-&#39;A&#39;+6]=c;//设置为可见 } puts(k);//直接输出 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1451 【求细胞数量】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-P1451-%E3%80%90%E6%B1%82%E7%BB%86%E8%83%9E%E6%95%B0%E9%87%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[怎么楼下都是bfs啊…… 忍不住来了一发dfs 其实dfs也挺快的啊，0ms呢…… 思路也很简单，搞一个数组，不为0的地方就是细胞，然后dfs搜连通块，把搜到的都归0，保证不重复。。。 然后就是循环找没被归0的，答案+1。 代码： #include &lt;bits/stdc++.h&gt; using namespace std; template &lt;typename _Tp&gt; inline void read(_Tp &amp;x){ int w=1;char c=0;x=0; while (c^&#39;-&#39;&amp;&amp;(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;))c=getchar(); if (c==&#39;-&#39;)w=-1,c=getchar(); while (c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x*=w; } inline void write(int n){ if(n==0) return; write(n/10); putchar(n%10+&#39;0&#39;); }//输入输出优化，请自动忽略 int n,m,ans,dx[]={-1,0,1,0},dy[]={0,-1,0,1},a[105][105];//a即地图，dx和dy方向增量数组就不用我讲了吧 void dfs(int x,int y){ if (x&gt;n||y&gt;m||x&lt;0||y&lt;0)return; a[x][y]=0;//标记为没有 for (int i=0;i&lt;4;i++)if (a[x+dx[i]][y+dy[i]])dfs(x+dx[i],y+dy[i]);//如果有才搜 }//搜索 int main(){ read(n),read(m); for (int i=0;i&lt;n;i++) for (int j=0;j&lt;m;j++)scanf(&quot;%1d&quot;,&amp;a[i][j]);//只读1位 for (int i=0;i&lt;n;i++) for (int j=0;j&lt;m;j++)if (a[i][j])ans++,dfs(i,j);//找 write(ans);//输出 return 0; } 好像挺简单的啊？]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3692 【夏幻的考试】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-P3692-%E3%80%90%E5%A4%8F%E5%B9%BB%E7%9A%84%E8%80%83%E8%AF%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这题很简单啊，代码也没有必要写那么长 就是按题目说的模拟 代码： #include &lt;bits/stdc++.h&gt; using namespace std; int n,m,ans[55];//ans[i]为第i题的正确序号（0，1，2，3） string s; int main(){ ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for (int i=0;i&lt;m;i++)ans[i]=s[i]-&#39;A&#39;;//读入标准答案 while (n--){ double cnt=0; int kh=0; cin&gt;&gt;s; for (int i=15;i&gt;=0;i--)kh+=(s[i]-&#39;0&#39;)*pow(2,15-i);//算考号 bool khzq=kh&gt;=1&amp;&amp;kh&lt;=10000;//检查是否合法 if (!khzq){ for (int i=0;i&lt;=m;i++)cin&gt;&gt;s; printf (&quot;Wrong ID\n\n&quot;);continue;//不合法 } cin&gt;&gt;s; if (s[0]==s[1])s[kh&amp;1]=&#39;0&#39;;//如果两个都填了或者两个都没填，让它变成错误 //不难发现考号%2就是最后一位，因为2的方冥都是偶的 printf (&quot;ID: %d\nType %s\n&quot;,kh,s[kh&amp;1]-&#39;0&#39;?&quot;Correct&quot;:&quot;Incorrect&quot;);//输出ID和是否正确 for (int i=0;i&lt;m;i++){ cin&gt;&gt;s; bool ok=0,f=0; for (int j=0;j&lt;4;j++)if (s[j]-&#39;0&#39;&amp;&amp;ok)f=1;//如果填了两个 else if (s[j]-&#39;0&#39;)ok=1;//如果填了 if (ok&amp;&amp;!f&amp;&amp;s[ans[i]]-&#39;0&#39;)cnt+=100.0/m;//只填了一个且填的是对的 } printf (&quot;%.1f\n\n&quot;,cnt);//输出 } return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF36A 【Extra-terrestrial Intelligence】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF36A-%E3%80%90Extra-terrestrial%20Intelligence%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题好坑啊…… 其实模拟并不难，但是输入和输出有坑： 输入要加freopen(“input.txt”,”r”,stdin) 输出要加freopen(“output.txt”,”w”,stdout)输入要加freopen(“input.txt”,”r”,stdin) 输出要加freopen(“output.txt”,”w”,stdout)输入要加freopen(“input.txt”,”r”,stdin) 输出要加freopen(“output.txt”,”w”,stdout)重要的事情说三遍 代码： #include&lt;cstdio&gt; int n,a[105],l1,l2; int main(void){ freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;output.txt&quot;,&quot;w&quot;,stdout); scanf (&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++){ scanf(&quot;%1d&quot;,&amp;a[i]); if(a[i]&amp;&amp;!l1)l1=i;//记录第一个1 else if (a[i]&amp;&amp;!l2)l2=i;//记录第2个1 } for (int i=l2+1;i&lt;=n;i++)if (a[i]&amp;&amp;i-l2==l2-l1)l1=l2,l2=i;//间隔相同，更新 else if(a[i])return !printf (&quot;NO&quot;);//不相同直接退出 printf (&quot;YES&quot;); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF228A 【Is your horseshoe on the other hoof?】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF228A-%E3%80%90Is%20your%20horseshoe%20on%20the%20other%20hoof%EF%BC%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题怎么没人做呢…… 其实看了我的翻译就知道是求4个数里有几个重复的-1 所以很简单了 代码很短就不写注释了 #include &lt;bits/stdc++.h&gt; using namespace std; int a[4],ans; int main(void){ scanf (&quot;%d%d%d%d&quot;,&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3]); sort (a,a+4); for (int i=1;i&lt;4;i++)if (a[i]==a[i-1])ans++; printf (&quot;%d&quot;,ans); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF977A 【Wrong Subtraction】]]></title>
    <url>%2F2019%2F01%2F16%2F%E9%A2%98%E8%A7%A3-CF977A-%E3%80%90Wrong%20Subtraction%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题很简单啊怎么没人做？ 直接按题目说的模拟就行了。 代码： #include &lt;cstdio&gt; long long n,k; int main(void){ scanf (&quot;%d%d&quot;,&amp;n,&amp;k); while (k--)if (n%10)n--;else n/=10;//模拟 printf (&quot;%lld&quot;,n);//输出 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF723A 【The New Year: Meeting Friends】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-CF723A-%E3%80%90The%20New%20Year%20Meeting%20Friends%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题非常简单，就是一个数论 首先，我们考虑最大和最小的两个数： 如果要他们的差最小，那么集合点必须在他们之间（绝对值的几何意义） 而这个点又可以设在中间值的点上，所以中间点的距离=0 所以此题的答案= $ max(a,b,c)-min(a,b,c)$ 代码： #include &lt;cstdio&gt; #define min(x,y) ((y)^(((x)^(y))&amp;(-((x)&lt;(y))))) #define max(x,y) ((x)^(((x)^(y))&amp;(-((x)&lt;(y))))) int main(void){ int a,b,c; scanf (&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); printf (&quot;%d&quot;,max(max(a,b),c)-min(min(a,b),c)); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1740 【Diamond A&B(1)】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1740-%E3%80%90Diamond%20A%26B(1)%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题有毒。。。 貌似就我一个是用C++写过的…… 楼下已经说过题目什么意思，我这里就来说一下怎么实现 具体请看代码 #include &lt;bits/stdc++.h&gt; using namespace std; int n; string a[1777]; int main(void){ cin&gt;&gt;n; cout&lt;&lt;n&lt;&lt;endl; for (int i=0;i&lt;=n*2;i++){ string s; getline(cin,s); a[i]=&quot; &quot;; a[i]+=s; }//由于string读入时自动0下标，所以我要强制转成1下标 for (int i=1;i&lt;=2*n+1;i++,puts(&quot;&quot;)){ int ps=n+!(i&amp;1),o=1+(i-1)/2,p=n+1-i/2;//ps是输出个数，o是起始行，p是起始列 for (int j=1;j&lt;=ps;j++)putchar(a[o++][p++]==&#39; &#39;?&#39;0&#39;:&#39;1&#39;);//模拟过去 } }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2152 【[SDOI2009]SuperGCD】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P2152-%E3%80%90%5BSDOI2009%5DSuperGCD%E3%80%91%2F</url>
    <content type="text"><![CDATA[人生中第一篇$ \color{purple} \text{紫题} $的题解 其实不得不指出楼下的一个错误： 使用py3写辗转相除法并不会RE！！！ 甚至连函数都不用，只要一个循环就好。 代码： a=int(input()) b=int(input()) while b&gt;0: c=b//先记下b b=a%b//改掉b a=c//改掉a print(a)]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1865 【A % B Problem】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1865-%E3%80%90A%20%25%20B%20Problem%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题大家应该都能看出来要用筛法+前缀和吧……所以我觉得这题顶多普及- 所以我来讲两个优化： 1. 其实前缀和并不用再开一个数组2. 前缀和其实并不是非要套在循环里绕，完了再特判，只需要再开一个循环就可以了具体看代码： #include &lt;cstdio&gt; int n,m,l,r,a[1000000]; void prime(){ for (int i=2;i&lt;=m;i++)if (!a[i]) for (int j=i*2;j&lt;=m;j+=i)a[j]=1;//标准线筛 for (int i=2;i&lt;=m;i++)a[i]=!a[i],a[i]+=a[i-1];//处理前缀和：直接在同一个数组里处理，a[i]=!a[i]是把原来对质数的标记0改成1，对合数的标记1改成0，然后就可以放心地加上前面的了 } template &lt;typename _Tp&gt; inline void read(_Tp &amp;x){ int w=1;char c=0;x=0; while (c^&#39;-&#39;&amp;&amp;(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;))c=getchar(); if (c==&#39;-&#39;)w=-1,c=getchar(); while (c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x*=w; } inline void write(int n){ if(n==0) return; write(n/10); putchar(n%10+&#39;0&#39;); } int main(){ read(n),read(m); prime(); while (n--){ read(l),read(r); if (l&lt;1||l&gt;m||r&lt;1||r&gt;m){puts(&quot;Crossing the line&quot;);continue;} if (a[r]-a[l-1])write(a[r]-a[l-1]);//标准前缀和输出方式 else putchar(&#39;0&#39;);puts(&quot;&quot;); } }//至于某些多打的部分是快读+快输，个人喜好。]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4711 【「化学」相对分子质量】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P4711-%E3%80%90%E3%80%8C%E5%8C%96%E5%AD%A6%E3%80%8D%E7%9B%B8%E5%AF%B9%E5%88%86%E5%AD%90%E8%B4%A8%E9%87%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[恩这题其实并没有那么难，根本没有必要搞什么单调栈什么的，所以我来一发很短的题解。 本题的思路就是逐个击破，我的思路是这样的： 1.元素对于单个元素的处理应该是很简单的，因为我们有强大的map，一个表就结束了。 2.下标这里我主要分两种情况看： 对原子的下标 只需要保存每个元素的值（last），如果发现下标就把已经加到ans里的last减掉，重新加上last×下标系数就可以了。 对原子团的下标 这个等会会在原子团的部分里解释 3.原子团这个对于原子团中可能出现的嵌套问题，我选择了递归解决 原子团中的原子跟原子团外的原子是一个解决方法（原子+下标） 然后接下来就是原子团的下标了 这个问题需要我们对原子团中的运算结果进行一个tmp的保存，然后在退出函数之前检查外面有没有下标，有的话立即解决。 4.水合物这个就很简单了，检测到~后直接计算系数，然后乘以18（H_{2}O的值）就可以了 具体的一些坑点会在代码里说 #include &lt;bits/stdc++.h&gt; using namespace std; double ans,last;//小心别手残打成int了（因为有.5的存在） string a; map &lt;string,double&gt; mp;//一个map其实可以帮我们很多忙 inline void start(){mp[&quot;H&quot;]=1; mp[&quot;C&quot;]=12; mp[&quot;N&quot;]=14; mp[&quot;O&quot;]=16; mp[&quot;F&quot;]=19; mp[&quot;Na&quot;]=23; mp[&quot;Mg&quot;]=24; mp[&quot;Al&quot;]=27; mp[&quot;Si&quot;]=28; mp[&quot;P&quot;]=31; mp[&quot;S&quot;]=32; mp[&quot;Cl&quot;]=35.5; mp[&quot;K&quot;]=39; mp[&quot;Ca&quot;]=40; mp[&quot;Mn&quot;]=55; mp[&quot;Fe&quot;]=56; mp[&quot;Cu&quot;]=64; mp[&quot;Zn&quot;]=65; mp[&quot;Ag&quot;]=108; mp[&quot;I&quot;]=127; mp[&quot;Ba&quot;]=137; mp[&quot;Hf&quot;]=178.5; mp[&quot;Pt&quot;]=195; mp[&quot;Au&quot;]=197; mp[&quot;Hg&quot;]=201;}//打表 int ys(int k){ string s=&quot;&quot;;int j=k+1;s+=a[k]; for (;a[j]&gt;=&#39;a&#39;&amp;&amp;a[j]&lt;=&#39;z&#39;;j++)s+=a[j]; ans+=last=mp[s];//存下上一个值，为下标作准备 return j; }//对单个元素处理：用string提取单个元素，然后直接拿mp映射表搞 int xb(int k){ int j=k+2,s=0; for (;a[j]&gt;=&#39;0&#39;&amp;&amp;a[j]&lt;=&#39;9&#39;;j++)s=s*10+a[j]-&#39;0&#39;; ans-=last,ans+=last*s; return j; }//外部下标 double tmp,tlast;//tmp为括号里的运算结果，tlast为括号里的上一个值 int xbk(int k){ int j=k+2,s=0; for (;a[j]&gt;=&#39;0&#39;&amp;&amp;a[j]&lt;=&#39;9&#39;;j++)s=s*10+a[j]-&#39;0&#39;; tmp-=tlast,tmp+=tlast*s; return j; }//括号里的下标 int ysk(int k){ string s=&quot;&quot;;int j=k+1;s+=a[k]; for (;a[j]&gt;=&#39;a&#39;&amp;&amp;a[j]&lt;=&#39;z&#39;;j++)s+=a[j]; tmp+=tlast=mp[s]; return j; }//括号里的元素 inline int kh(int k){ int j=k+1,h=1;//h表示当前未匹配的左括号数 while (h!=0){ if (a[j]==&#39;)&#39;)h--;//匹配到一个 if (!h)break; if (a[j]&gt;=&#39;A&#39;&amp;&amp;a[j]&lt;=&#39;Z&#39;){ j=ysk(j); if (a[j]==&#39;_&#39;)j=xbk(j)+1; }else if (a[j]==&#39;(&#39;)h++,j=kh(j);//又出来一个，递归 } if (a[j+1]==&#39;_&#39;)ans+=tmp,last=tmp,j=xb(j+1);//原子团的下标 tmp=0;//记得归0 return j; }//括号 void sh(int k){ int j=k+1,f=0; for (;a[j]&gt;=&#39;0&#39;&amp;&amp;a[j]&lt;=&#39;9&#39;;j++)f=f*10+a[j]-&#39;0&#39;; if (!f)f++;//注意！！！如果f没提取到说明省略了系数，千万别忘了默认为1！ ans+=f*18; }//水合物 int main(){ start(); cin&gt;&gt;a; for (int i=0;i&lt;a.size();i++){ if (a[i]&gt;=&#39;A&#39;&amp;&amp;a[i]&lt;=&#39;Z&#39;)i=ys(i)-1; else if (a[i]==&#39;_&#39;)i=xb(i); else if (a[i]==&#39;(&#39;)i=kh(i); else if (a[i]==&#39;~&#39;){sh(i);break;} } printf (&quot;%g&quot;,ans);//%g的输出可以省掉多余的0 return 0; }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2682 【土豆田】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P2682-%E3%80%90%E5%9C%9F%E8%B1%86%E7%94%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[经过看楼下的题解我也AC了 AC记录：AC 此题每问的做法楼下都已经讲过了，我就来一发具体的代码+写代码的技巧 此题有一个坑点就是必须控制程序的运行次数，然而很多都不好卡。（比方说#2测试点我就卡了好久） 以#2为例，将a*233分解为： $ a233=a128+a64+a32+a*8+a $ 如果用一个土豆，好像没办法卡进9cycles. 那么怎么办呢？ 我就把 $ a128+a $分配给1号土豆，然后再负责加上2号土豆算的 $ a64+a32 $，把结果传回给2号土豆，2号土豆并负责加上3号土豆算的 $ a8 $，最后的结果由4号土豆汇总并输出。 答案：我等急死了 答案： 1.1 2 3 in swap opp 5 in swap get l add tmp out 2.2 2 6 in add tmp L 7 add tmp get r add tmp 7 wait get l add tmp L 6 R 1 get l add tmp 4 wait get u swap L 3 9 wait wait wait get l add tmp wait get u add tmp out 3.1 1 7 in add tmp R 31 swap add tmp xor tmp out 4.4 2 32 in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp 34 in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp get l add tmp 32 in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp 36 in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp get l add tmp get u add tmp 32 in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp 39 in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp get l add tmp get d add tmp get u add tmp out 32 in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp 34 in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp in add tmp get l add tmp 这打表一样的代码 5.1 2 5 in swap get r xor tmp R 1 7 in swap get l and tmp get l add tmp out 不知为何下面的一段代码不对： 1 1 6 in swap in add tmp R 1 out 知道的可以私信告诉我QAQ 6.1 2 23 in add tmp R 1 and 1431655765 get r add tmp R 2 and 858993459 get r add tmp R 4 and 252645135 get r add tmp R 8 and 16711935 get r add tmp R 16 and 65535 get r add tmp out 20 wait get l add tmp and 1431655765 wait get l swap and 858993459 wait get l swap and 252645135 wait get l swap and 16711935 wait get l swap and 65535 原本的C++代码是这个： #include &lt;cstdio&gt; int func(unsigned int i) { unsigned int temp = i; temp = (temp &amp; 0x55555555) + ((temp&gt;&gt; 1) &amp; 0x55555555); //temp相邻位相加 temp = (temp &amp; 0x33333333) + ((temp &gt;&gt; 2) &amp; 0x33333333); //temp相邻（以2为单位）相加 temp = (temp &amp; 0x0f0f0f0f) + ((temp&gt;&gt; 4) &amp; 0x0f0f0f0f); //temp相邻（以4为单位）相加 temp = (temp &amp; 0xff00ff) + ((temp&gt;&gt; 8) &amp; 0xff00ff); //temp相邻（以8为单位）相加 temp = (temp &amp; 0xffff) + ((temp&gt;&gt; 16) &amp; 0xffff) ; //temp相邻（以16为单位）相加 return temp; } int main(void){ int a; scanf (&quot;%d&quot;,&amp;a); printf (&quot;%d&quot;,func(a)); } 我纯人工把改写了23行（流泪） 这打表一样的代码*2，怪不得被楼下和谐了 7.1 1 3 in swap out 肮脏的我为了不动脑子，果断地利用了SPJ的bug 8.1 1 254 in set tmp add -1 if key goto 9 set 1 out end add -1 if key goto 15 set 2 out end add -1 if key goto 21 set 3 out end add -1 if key goto 27 set 5 out end add -1 if key goto 33 set 8 out end add -1 if key goto 39 set 13 out end add -1 if key goto 45 set 21 out end add -1 if key goto 51 set 34 out end add -1 if key goto 57 set 55 out end add -1 if key goto 63 set 89 out end add -1 if key goto 69 set 144 out end add -1 if key goto 75 set 233 out end add -1 if key goto 81 set 377 out end add -1 if key goto 87 set 610 out end add -1 if key goto 93 set 987 out end add -1 if key goto 99 set 1597 out end add -1 if key goto 105 set 2584 out end add -1 if key goto 111 set 4181 out end add -1 if key goto 117 set 6765 out end add -1 if key goto 123 set 10946 out end add -1 if key goto 129 set 17711 out end add -1 if key goto 135 set 28657 out end add -1 if key goto 141 set 46368 out end add -1 if key goto 147 set 75025 out end add -1 if key goto 153 set 121393 out end add -1 if key goto 159 set 196418 out end add -1 if key goto 165 set 317811 out end add -1 if key goto 171 set 514229 out end add -1 if key goto 177 set 832040 out end add -1 if key goto 183 set 1346269 out end add -1 if key goto 189 set 2178309 out end add -1 if key goto 195 set 3524578 out end add -1 if key goto 201 set 5702887 out end add -1 if key goto 207 set 9227465 out end add -1 if key goto 213 set 14930352 out end add -1 if key goto 219 set 24157817 out end add -1 if key goto 225 set 39088169 out end add -1 if key goto 231 set 63245986 out end add -1 if key goto 237 set 102334155 out end add -1 if key goto 243 set 165580141 out end add -1 if key goto 249 set 267914296 out end add -1 if key goto 255 set 433494437 out end 老师说过goto不好不要乱用，然而还是看到了这不和谐的代码 我的第一份黑题题解，大家谅解一下自认为高清无码的标准答案还是大家喜闻乐见的]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1721 【[NOI2016]国王饮水记】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1721-%E3%80%90%5BNOI2016%5D%E5%9B%BD%E7%8E%8B%E9%A5%AE%E6%B0%B4%E8%AE%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实此题根本不用那么麻烦，一个贪心即可。 贪心策略也很简单，就是原则1：能连2个不连3个 为什么呢？我们举例验证。 例：$n=3,h1=1,h2=1.7,h3=3$ 这时，如果连通1、2、3，水位为$ \frac{1+1.7+3}{3}=1.9 $，而如果连通1、3，水位为$ \frac{1+3}{2}=2$，这时，由于2的水位低于平均数，所以2反而拖了后腿。 有没有办法利用2呢？ 有。 如果先连通1、2，水位为$\frac{1+1.7}{2}=1.35 $，再连通1、3，水位为$\frac{1.35+3}{2}=2.175$，比刚才高。 所以得到一个推论：原则2：如果要加入一个城市进入连通器，它的水位一定要比已有平均数高 在一般情况下，尽量一次连2个；如果k不够用，则用原则2，将2次的连通并为一次。 接下来就是难点：恶心毒瘤的保留p位小数的高精除。$ \color{black} \colorbox{black}{所以根本不用写700行代码啊？} $ 最优解的代码：（为了好看我改了一点） #include&lt;bits/stdc++.h&gt; int N,n,m,p; int h[8192],s[8192];//8192=2&lt;&lt;13 double f[16][8192]; int g[16][8192]; int a[400]; using namespace std; #define P pair&lt;int,double&gt; double operator%(const P&amp;a,const P&amp;b){ return (b.second-a.second)/(b.first-a.first); }//重载运算符 void div(int x){ long long q=0; for(int i=0;i&lt;=p;i++){ q=q*1000000000+a[i];a[i]=q/x;q%=x; } }//恶心的除，用重载运算符实现 int main(){ scanf(&quot;%d%d%d&quot;,&amp;N,&amp;m,&amp;p);p=p/9+1; scanf(&quot;%d&quot;,&amp;h[n=1]); for(int i=2;i&lt;=N;i++){ int t;scanf(&quot;%d&quot;,&amp;t);if(h[1]&lt;t)h[++n]=t; } sort(h+1,h+n+1); if(m&gt;n)m=n; for(int i=1;i&lt;=n;i++)f[0][i]=h[1],s[i]=s[i-1]+h[i];//前缀和 int l=14;if(l&gt;m)l=m; for(int i=1;i&lt;=l;i++){ static P q[8024]; for(int j=2,l=1,r=0;j&lt;=n;j++){ P c=P(j-2,s[j-1]-f[i-1][j-1]); for(;l&lt;r&amp;&amp;(q[r-1]%q[r])&gt;(q[r]%c);r--); q[++r]=c; P t=P(j,s[j]); for(;l&lt;r&amp;&amp;(q[l]%t)&lt;(q[l+1]%t);l++); g[i][j]=q[l].first+1; f[i][j]=(q[l]%t); } } int _[16];_[l]=n-(m-l); for(int i=l;i;i--)_[i-1]=g[i][_[i]]; a[0]=h[1]; for(int i=1;i&lt;=l;i++)a[0]+=s[_[i]]-s[_[i-1]],div(_[i]-_[i-1]+1); for(int i=_[l]+1;i&lt;=n;i++)a[0]+=h[i],div(2);//以上为贪心 printf(&quot;%d.&quot;,a[0]); for(int i=1;i&lt;=p;i++)printf(&quot;%09d&quot;,a[i]); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1983 【车站分级】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1983-%E3%80%90%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7%E3%80%91%2F</url>
    <content type="text"><![CDATA[我来这里发题解只是为了证明：某种被认为是非正解的算法，其实是可以AC的！ 先看：https://www.luogu.org/blog/user56917/solution-p1983 其实，我并没有改动多少，只是进行了几个很常用的优化： 避免重复定义变量 在原来的代码中，有一段是这样的： for(register int iii=1;iii&lt;=m;iii++){ int cnt=get(); 在这一段中，cnt被反复定义了$ m $次，导致了时间的浪费，因为这明明是一个可以一次解决的问题。 少写头文件 你写的头文件中的函数每调用一次，编译器就载入一次，所以记住这个原则： $ \text{函数能手打就手打，头文件能不调用就不调用} $ 所以我省去了iostream头文件，没用using namespace std;，而是手写了max：#define max(x,y) ((x)^(((x)^(y))&amp;(-((x)&lt;(y))))) 不用cin/cout cin/cout其实很慢的，如果你被卡常了，记得换成快读/快输 经过这几个优化，就可以AC了，第8个点只用了832ms。 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #define max(x,y) ((x)^(((x)^(y))&amp;(-((x)&lt;(y))))) //手写max template &lt;typename _Tp&gt; inline void read(_Tp &amp;x){ int w=1;char c=0;x=0; while (c^&#39;-&#39;&amp;&amp;(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;))c=getchar(); if (c==&#39;-&#39;)w=-1,c=getchar(); while (c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x*=w; } inline void write(int n){ if(n==0) return; write(n/10); putchar(n%10+&#39;0&#39;); }//快读/快输 int que[100000000],dis[2011],v[1011][1011],ints[10000],qian[1011][1011],n,m,ans,cnt;//变量尽量一次定义 unsigned char bv[2011],G[1011][1011],st[2011]; inline void add(int s,int t,int l){ G[s][t]=1; v[s][t]=max(v[s][t],l); } int main(){ read(n),read(m); for(register int iii=1;iii&lt;=m;iii++){ read(cnt); memset(bv,0,sizeof(bv)); for(register int i=1;i&lt;=cnt;i++)read(ints[i]),bv[ints[i]]=1; for(register int i=1;i&lt;=cnt;i++) for(register int j=ints[1];j&lt;=ints[cnt];j++)if(!bv[j])add(j,ints[i],1); }//register定义变量很快的 memset(bv,0,sizeof(bv)); for(register int i=1;i&lt;=n+1;i++)dis[i]=-1234567890; register int head=0,tail=1;que[0]=n+1; dis[n+1]=0; for(register int i=1;i&lt;=n;i++)add(n+1,i,1); for(register int i=1;i&lt;=n+1;i++) for(register int j=1;j&lt;=n+1;j++) if(i!=j&amp;&amp;G[i][j])qian[i][0]++,qian[i][qian[i][0]]=j; do{ int me=que[head];head++;bv[me]=0; for(register int j=1;j&lt;=qian[me][0];j++){ int i=qian[me][j]; if(dis[me]+v[me][i]&gt;dis[i]){ dis[i]=dis[me]+v[me][i]; if(!bv[i])bv[i]=1,que[tail++]=i; } } }while(head&lt;tail); for(register int i=1;i&lt;=n;i++)st[dis[i]]=1; for(register int i=1;i&lt;=1000;i++)ans+=st[i]; write(ans); return(0); } 原解法：这篇文章摆在一起]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4212 【外太空旅行】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P4212-%E3%80%90%E5%A4%96%E5%A4%AA%E7%A9%BA%E6%97%85%E8%A1%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题目其实是bitset的一个很好的应用，再结合一下楼下的随机数算法即可AC。 注意一下，由于两个人之间要么是朋友要么是敌人，那么我们可以考虑将两个人之间的关系改为2进制。这就是bitset的原理。 bitset很强大，可以对很多数据类型进行转换，重点是：支持运算操作！ 那么这题的做法就很显然了：直接用一个bitset now 来维护当前顺序可以入选的名单（用 &amp; 运算可以模拟水火不容 or 基♂情满满） 剩下来的就是用随机生成顺序来取最大值了，最后存答案的bitset ans 的数量（ $ ans.count() $ 就是答案）。（ans中1的个数即表示有多少人能和睦相处） 代码就不贴了，只有18行，相信大家都能打出来。]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4907 【A换B problem】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P4907-%E3%80%90A%E6%8D%A2B%20problem%E3%80%91%2F</url>
    <content type="text"><![CDATA[出题人来写一发题解 此题主要就是搜索，为了提升难度，我还搞了一个恶心的读入 接下来就是搜索了。 具体码里说吧。 #include &lt;bits/stdc++.h&gt; using namespace std; bool a[5][14]; int ans,p,k,n,i,ant; char ch; string st; bool bb; bool check() { int i,j,t; bool b; for (j=1; j&lt;=4; j++) { t=0; b=false; for (i=1; i&lt;=k; i++)if (a[j][i])t++; i=0; if (t==1||t==13)continue; while (i&lt;k) { i++; if (t==0)break; if (a[j][i]) { t--; if (b) continue; else b=true; } else if (b)return false; else continue; } } return true; }//判断是否连续（即换完后是否可行） void check2() { int i,j,t,y; bool b; y=0; for (j=1; j&lt;=4; j++) { t=0; for (i=1; i&lt;=k; i++)if (a[j][i])t++; i=0; if (t==0||t==13||t==1) continue; b=false; while (i&lt;k) { i++; if (t==0) break; if (a[j][i]) { t--; if (b) continue; else b=true; } else if (b)y++; else continue; } } if (y&lt;ant) ant=y; }//同上，另一个判断 void search(int q,int b) { int i,j,o,y[5],w[5]; if (q==k+1) { if (check()) { bb=true; if (ans&gt;b) ans=b; } if (!bb) check2(); return ; } search(q+1,b); j=0; for (i=1; i&lt;=4; i++) if (a[i][q]) { j++; y[j]=i; } else { w[i-j]=i; } if (j==4||j==0)return ; if (j==1||j==3) { if (j==3) { for (o=1; o&lt;=3; o++) { if (a[i][j+1]&amp;&amp;a[i][j-1])continue; if (!(a[o][j+1]||a[o][j-1]))continue; a[w[1]][q]=true; a[y[o]][q]=false; search(q+1,b+1); a[w[1]][q]=false; a[y[o]][q]=true; } } if (j==1) { for (o=1; o&lt;=3; o++) { if (a[i][j+1]&amp;&amp;a[i][j-1])continue; //if (!(a[o][j+1]||a[o][j-1]))continue; a[w[o]][q]=true; a[y[1]][q]=false; search(q+1,b+1); a[w[o]][q]=false; a[y[1]][q]=true; } } } else { for (o=1; o&lt;=2; o++) { if (a[i][j+1]&amp;&amp;a[i][j-1])continue; if (!(a[o][j+1]||a[o][j-1]))continue; a[w[o]][q]=true; a[y[1]][q]=false; search(q+1,b+1); a[w[o]][q]=false; a[y[1]][q]=true; a[w[o]][q]=true; if (a[i][j+1]&amp;&amp;a[i][j-1])continue; if (!(a[o][j+1]||a[o][j-1]))continue; a[y[2]][q]=false; search(q+1,b+1); a[w[o]][q]=false; a[y[2]][q]=true; } a[w[1]][q]=true; a[y[1]][q]=false; a[w[2]][q]=true; a[y[2]][q]=false; search(q+1,b+2); a[w[1]][q]=false; a[y[1]][q]=true; a[w[2]][q]=false; a[y[2]][q]=true; } }//搜索，具体过程就是分类讨论，对每个牌的编号+1、-1进行搜索 int main() { cin&gt;&gt;n; for (i=1; i&lt;=n; i++) { cin&gt;&gt;p&gt;&gt;st; if (st==&quot;A&quot;) { a[p][1]=true; if (1&gt;k)k=1; } if (st==&quot;2&quot;) { a[p][2]=true; if (2&gt;k)k=2; } if (st==&quot;3&quot;) { a[p][3]=true; if (3&gt;k)k=3; } if (st==&quot;4&quot;) { a[p][4]=true; if (4&gt;k)k=4; } if (st==&quot;5&quot;) { a[p][5]=true; if (5&gt;k)k=5; } if (st==&quot;6&quot;) { a[p][6]=true; if (6&gt;k)k=6; } if (st==&quot;7&quot;) { a[p][7]=true; if (7&gt;k)k=7; } if (st==&quot;8&quot;) { a[p][8]=true; if (8&gt;k)k=8; } if (st==&quot;9&quot;) { a[p][9]=true; if (9&gt;k)k=9; } if (st==&quot;10&quot;) { a[p][10]=true; if (10&gt;k)k=10; } if (st==&quot;J&quot;) { a[p][11]=true; if (11&gt;k)k=11; } if (st==&quot;Q&quot;) { a[p][12]=true; if (12&gt;k)k=12; } if (st==&quot;K&quot;) { a[p][13]=true; if (13&gt;k)k=13; }//鬼畜的读入 } ans=255; ant=255; search(1,0); if (bb) { puts(&quot;Yes&quot;); printf (&quot;%d\n&quot;,ans); } else { puts(&quot;No&quot;); printf (&quot;%d\n&quot;,ant); }//输出 }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5003 【跳舞的线 - 乱拐弯】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P5003-%E3%80%90%E8%B7%B3%E8%88%9E%E7%9A%84%E7%BA%BF-%E4%B9%B1%E6%8B%90%E5%BC%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[其实这题完全没有楼下讲的那么难……我就来解释一下我的思路吧 首先，(i,j)这个点的答案肯定由(i-1,j)和(i,j-1)的答案确定（因为只准往下、往右走） 我设到达(i,j)时的最大拐弯数为f[i][j]，则有 f[1][1…n]=0 f[1…n][1]=0 我用h[i][j]表示到(i,j)的走向（0表示向右，1表示向下，2表示任意） 则可以得到转移： $f[i][j]=max(f[i-1][j]+(h[i-1][j]!=1),f[i][j-1]+(h[i-1][j]!=0))$ 为什么用!=而不用==呢？因为是求最大拐弯数，所以能拐我一定拐，!=保证了当上一个点只要不是当前方向就一定拐。 这也是h数组中2的用处。 因为不仅要答案，还要求h数组，所以这个max我是用if分类讨论实现的 同理可得，$g[i][j]=min(g[i-1][j]+(k[i-1][j]==0),g[i][j-1]+(k[i][j-1]==1))$，这里的==保证了能不拐我绝对不拐 然后就是一个坑：要先跑一遍，看能不能到。 最后初始化：$f[2…n][2…m]=-(1&lt;&lt;11),g[2…][2…m]=1&lt;&lt;11,h[1…n][1]=1 \text{因为向下走只有1种可能}$ 具体细节看代码： #include &lt;bits/stdc++.h&gt; using namespace std; int n,m,f[1005][1005],g[1005][1005],h[1005][1005],k[1005][1005]; char c; bool v[1005][1005],can[1005][1005]; int check(int i,int j){ if (can[i-1][j]&amp;&amp;can[i][j-1])return 2; else if (can[i-1][j])return 1; else return 0; }//在分类讨论中，判断当从(i-1,j)和(i,j-1)过来且拐弯数相同时哪一种可行 int main(){ cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++){ cin&gt;&gt;c; if (c==&#39;#&#39;)v[i][j]=1,can[i][j]=0;//标记为不可走 } can[1][1]=!v[1][1]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ can[i][j]|=can[i-1][j]|can[i][j-1]; if (v[i][j])can[i][j]=0; } if (!can[n][m])return !printf (&quot;-1&quot;);//看能不能过 for (int i=2;i&lt;=n;i++) for (int j=2;j&lt;=m;j++)f[i][j]=-(1&lt;&lt;11),g[i][j]=1&lt;&lt;11;//初始化 for (int i=1;i&lt;=n;i++)h[i][1]=k[i][1]=1; for (int i=2;i&lt;=n;i++) for (int j=2;j&lt;=m;j++)if (can[i][j]){ if (f[i-1][j]+(h[i-1][j]!=1)&gt;f[i][j-1]+(h[i][j-1]!=0)&amp;&amp;(can[i-1][j]))f[i][j]=f[i-1][j]+(h[i-1][j]!=1),h[i][j]=1;//从(i-1,j)过来可行且更优 else if (f[i-1][j]+(h[i-1][j]!=1)==f[i][j-1]+(h[i][j-1]!=0))f[i][j]=f[i-1][j]+(h[i-1][j]!=1),h[i][j]=check(i,j);//相同 else if (can[i][j-1])f[i][j]=f[i][j-1]+(h[i][j-1]!=0),h[i][j]=0;//(i,j-1)更优 if (g[i-1][j]+(k[i-1][j]==0)&lt;g[i][j-1]+(k[i][j-1]==1)&amp;&amp;(can[i-1][j]))g[i][j]=g[i-1][j]+(k[i-1][j]==0),k[i][j]=1; else if (g[i-1][j]+(k[i-1][j]==0)==g[i][j-1]+(k[i][j-1]==1))g[i][j]=g[i-1][j]+(k[i-1][j]==0),k[i][j]=check(i,j); else if (can[i][j-1])g[i][j]=g[i][j-1]+(k[i][j-1]==1),k[i][j]=0;//同上 } if (f[n][m]&gt;0)printf (&quot;%d %d\n&quot;,f[n][m],g[n][m]); else putchar(&#39;-&#39;),putchar(&#39;1&#39;); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3386 【【模板】二分图匹配】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P3386-%E3%80%90%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E3%80%91%2F</url>
    <content type="text"><![CDATA[考前发个题解涨涨RP 感谢@nederland 巨佬提供了一个网络最大流+邻接矩阵的解法，我就在这里提一下如何优化 原解法：https://www.luogu.org/recordnew/lists?uid=nederland&amp;pid=P3386&amp;status=14&amp;sort=0 可以看到，除第一个AC以外，剩下来的T死…… 那么，如何优化呢？ 1. 快读+快输！这个东西，大家都知道，我就不解释了 2. O(3)虽说NOIP不给用，然而在此题中还是很有用的 3. register这是一个C++保留字，用来将变量存入内存，加速。 4. 避免变量重复定义这个东西有效优化时间。比方说一个1000000的循环，你定义一个变量，定义1000000次，不T都怪。相比之下，虽然仍然需要赋值，但减少了重复定义的时间。 用了这些，此题就可以A了啊…… 代码： #include&lt;cstdio&gt; #pragma GCC optimize(3) #define min(x,y) ((y)^(((x)^(y))&amp;(-((x)&lt;(y))))) bool vis[2005]; int pred[2005],cap[2005][2005],flow[2005][2005],N,t; inline char nc(){ static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; } template &lt;typename _Tp&gt; inline void read(_Tp &amp;x){ int f=1;x=0;char ch=nc(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=nc();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=nc();} x*=f; } inline void write(long long n){ if(n==0) return; write(n/10); putchar(n%10+&#39;0&#39;); }//快读+快输……然而printf比快输还快（我写炸了？） int findpath(int u,int x){ if(u==t)return x; vis[u]=true; for(int v=0;v&lt;N;v++){ if(!vis[v]){ int dt=cap[u][v]-flow[u][v]; if(dt&gt;0){ pred[v]=u; int r=findpath(v,min(x,dt)); if(r)return r; } } } return 0; } int main(){ register int n,m,s,e,r,v,i,u;//优化3、4 read(n),read(m),read(e);//优化1 s=0;t=n+m+1;N=n+m+2; for(i=1;i&lt;=n;i++)cap[s][i]=1; for(i=1;i&lt;=m;i++)cap[n+i][t]=1; for(i=0;i&lt;e;i++){ read(u),read(v);//优化1 if(u&gt;n||v&gt;m)continue; cap[u][v+n]=1; } while(true){ for(i=0;i&lt;N;i++)vis[i]=false; r=findpath(s,999999999); if(!r)break; v=t; while(v!=s){ u=pred[v]; flow[u][v]+=r; flow[v][u]-=r; v=u; } } register int sum=0; for(i=0;i&lt;N;i++)sum+=flow[s][i]; printf(&quot;%d&quot;,sum); return 0; } 由@nederland 巨佬的代码优化而来]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5019 【铺设道路】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P5019-%E3%80%90%E9%93%BA%E8%AE%BE%E9%81%93%E8%B7%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题目就我一个人模拟吗？ 普及蒟蒻，不会好算法，就来说一发模拟吧 首先一个贪心： 每次选一个连续正深度的坑的区间去填为什么呢？因为只有这样，才能保证我每次填坑的数量最多，不会造成浪费（即可以一天解决的问题我2天解决），也就是保证填的天数最少 于是得到了$ O(n^2* sum(a[1…n])) $，嗯，超时成什么样我就不说了 于是优化： 观察下面的表： d[1] d[2] d[3] d[4] d[5] d[6] d[7] 1 4 3 3 4 3 3 0 3 2 2 3 2 2 0 2 1 1 2 1 1 0 1 0 0 1 0 1 0 0 0 0 0 0 0 可以发现，第2行与第3行实际上是重复的 在本例中，只重了2行； 如果重个10000，100000行呢？ 那么你的程序就会T。 如何优化？ 不难发现，我们填坑的过程是有规律的； 于是就有了优化： 每次循环必然要彻底填掉至少1个坑 那么，实现就很简单了： 在找连续整数的时候，顺便查找最小值，然后区间减最小值，完成目标。 到此为止，你已经拿到80分了 还有两个点什么情况？ 因为，尽管我们优化了，整个复杂度还是$ O(n^{2}) $，是会T的 再优化！ 我们可以发现，当我们找区间的开始的时候，其实是有单调性的 即：我下一次填坑的起始点一定在本次填坑的范围中那么在模拟减的时候就可以顺便找下一次的开始了。 你也许发现了一个问题： 一遍坑全部填平了怎么办？ 没事，设定一个极值，最后判一下，如果没变的话就从本次的结束点往后找啦~ 于是复杂度降到了$ O(n+\text{常数}) $，就AC了 代码： #include &lt;bits/stdc++.h&gt; using namespace std; int n,d[100005],q=1; long long s,ans; int main(){ scanf (&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++)scanf (&quot;%d&quot;,&amp;d[i]),s+=d[i];//读入，统计和 int b=1; while (d[b]==0)b++;//找开端 q=b;//下一个开端 while (s){ b=q; int e=b,mn=1&lt;&lt;20; while (d[e])mn=min(mn,d[e]),e++;//找最小值 ans+=mn,s-=mn*(e-b);//花mn天干，总和减去填的所有 q=1&lt;&lt;20; for (int i=e-1;i&gt;=b;i--){d[i]-=mn;if (d[i]&gt;0)q=i;}//模拟减，同时找下一次的开端 if (q==1&lt;&lt;20)for (q=e+1;q&lt;=n;q++)if(d[q]&gt;0)break; } printf (&quot;%d&quot;,ans); }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4432 【[COCI2017-2018#2] ZigZag】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P4432-%E3%80%90%5BCOCI2017-2018%232%5D%20ZigZag%E3%80%91%2F</url>
    <content type="text"><![CDATA[没有C++题解？我来一发 这题目实际上可以用C++vector轻松解决 具体代码里说吧 // luogu-judger-enable-o2 #include &lt;bits/stdc++.h&gt; #include &lt;vector&gt; using namespace std; int n,k,q[30];//q为以a开头的单词中应该选的序号 vector &lt;string&gt; a[30];//建立一个以首字母序号为索引的vector char c; int main(){ scanf(&quot;%d%d&quot;,&amp;k,&amp;n); while(k--){ string s; cin&gt;&gt;s; a[s[0]-&#39;a&#39;].push_back(s);//vector的基本用法 } for (int i=0;i&lt;26;i++)sort(a[i].begin(),a[i].end());//C++对string的排序默认按字典序 while (n--){ cin&gt;&gt;c; cout&lt;&lt;a[c-&#39;a&#39;][q[c-&#39;a&#39;]]&lt;&lt;endl; q[c-&#39;a&#39;]=(q[c-&#39;a&#39;]+1)%a[c-&#39;a&#39;].size();//+1指向下一个，同时取模 //经观察可发现： //单词：zadar zoo //次数：0 0 //第一次选zadar： // zadar zoo // 1 0 //则第二次选zoo： // zadar zoo // 1 1 //第三次又选zadar： // zadar zoo // 2 1 //… //则可以发现：无论有多少次，在同一字母开头的单词中下标一直单调递增 //所以直接+1就可以啦。 } }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1918 【保龄球】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-P1918-%E3%80%90%E4%BF%9D%E9%BE%84%E7%90%83%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题竟然没有C++set的，STL会伤心的QAQ 我先讲一下本题的暴力做法 不解释，读入n个数据，然后对于每个m查找。 代码： #include &lt;bits/stdc++.h&gt; using namespace std; int n,m,a[100005],q; int main(){ scanf (&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++)scanf (&quot;%d&quot;,&amp;a[i]); scanf (&quot;%d&quot;,&amp;q); while (q--){ bool ok=0; scanf (&quot;%d&quot;,&amp;m); for (int i=1;i&lt;=n&amp;&amp;!ok;i++)if (a[i]==m)ok=printf (&quot;%d\n&quot;,i); if (!ok)printf (&quot;0\n&quot;); } } 非常简单，于是快乐的T了。 观察一下，T的效率瓶颈在于 for (int i=1;i&lt;=n&amp;&amp;!ok;i++)if (a[i]==m)ok=printf (&quot;%d\n&quot;,i); 这里是朴素的查找，最坏会退化到O(n)的级别 那么如何优化呢？ 此处分出了2条思路： 1.用map搞映射这玩意相当于开了一个非常大的桶，而且也有题解讲了，我就不多说了 2.用STL的lower_bound首先讲一下为什么用lower_bound。 因为lower_bound是找第一个≥n的元素，所以如果在数组中有n的话一定会找到n。 然后又分出了2条思路： 用结构体重载运算符 这个也有题解介绍了，我就不说了 用set 大家都知道，set按第一关键字排序，所以我们可以用结构体的思想，用set维护一个二元组(s,id)，s为具体值，id为行号。接下来就可以愉快地用lower_bound啦~ 代码： // luogu-judger-enable-o2 #include &lt;bits/stdc++.h&gt; using namespace std; set&lt;pair&lt;int,int&gt; &gt; st;//新建一个set int n,m,q,s; int main(){ ios::sync_with_stdio(false); cin.tie(0),cout.tie(0);//加速流读入 cin&gt;&gt;n; for (register int i=1;i&lt;=n;i++){ cin&gt;&gt;s; st.insert(make_pair(s,i));//插入二元组 } cin&gt;&gt;q; while (q--){ cin&gt;&gt;m; set&lt;pair&lt;int,int&gt; &gt;::iterator it=st.lower_bound(make_pair(m,0)); if (it-&gt;first==m)cout&lt;&lt;(it-&gt;second)&lt;&lt;endl;//如果能找到m，输出id； else cout&lt;&lt;0&lt;&lt;endl;//找不到输出0 } }]]></content>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF479A 【Expression】]]></title>
    <url>%2F2019%2F01%2F12%2F%E9%A2%98%E8%A7%A3-CF479A-%E3%80%90Expression%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题目就是个水题 思路楼下P党的题解已经说的很清楚了 我就来一发C++的代码 #include &lt;bits/stdc++.h&gt; using namespace std; int a,b,c; int main(){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;max(max(max(max(max(a*b*c,a+b+c),a*(b+c)),(a+b)*c),a+b*c),a*b+c);//恶心的5个max连求 } 别问我为什么题解这么短，因为真的没什么好说的]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[省赛之旅]]></title>
    <url>%2F2019%2F01%2F12%2F%E7%9C%81%E8%B5%9B%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[我要写一篇省赛的游记 Day1周四。晚上疯狂地写完作业，到洛谷上颓了2小时。哎，明天就走，不能不刷题了，何况还报了高中。 Day2周五上午早上下起了小雨，心情有点忧伤。本来请的是下午的假，现在因为怕堵车把上午3、4两节也请了。后来才发现我逃了一个听写 第三节英语课。果断地收拾书包离开，先跟英语老师再见，然后觉得这样走很奇怪，于是又跟同学们再见了一下。英语老师说我有领导气质？什么鬼……只是模仿领导人挥了一下手而已 中午没有事，吃完就出发了。下午到了省城。仍然是工作人员找不到准考证 试机先试高中组。旁边两个大佬的对话如下： 大佬A：昨天写了一个网络流。你说我要不要再写一遍？ 大佬B：早上写了一个费用流，我觉得我不一定能AK 我在一旁被完全碾压 初中组就完全不一样了 一群人大喊：啊，这个DP怎么这么难啊 别人：我要不要写一个DP呢？ 我：哼。DP？多简单啊，反正我有模板……我还是研究一下随机数算法吧。然而编译并没有过…… 晚上回宾馆颓 Day3周六上午AHOI高中组本来是7：40进考场，但是由于要排队，竟然拖到8:05还没有进考场。 好不容易进了，然后发现发了一个假的zip？ 传说中的 .7z文件！什么鬼…… 先打第一题。疯狂地打了98行的找规律，最后发现愉快的WA了。 果断改成递归。 此时已过去2hours。 第二题本来以为很难，环形模拟？40分get 第三题根本看不懂，于是愉快地递归 此三题在洛谷上： 估分：30+40+30=100 实际：？+？+？=30 下午AHOI初中组前三题愉快地AC了样例，开始做最后一题 此时还剩2：55分 结果是，第四题拿了30分质数点后，手打字典序，可惜我忘了STL那个命令叫什么。 于是估分100+100+100+30=330 结果：100+0+30+0=130 晚上回宾馆发现我橙了 Day4上午仍然是搞事情的.7z文件 结果，我打了一个第一题的模拟，可能得了30分。 回去发现两天加起来才60分。。。 我还是太渣了，回去练练吧。 谨以此纪念我逝去的初一OI]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018颓废之路]]></title>
    <url>%2F2019%2F01%2F12%2FNOIP2018%E9%A2%93%E5%BA%9F%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[初赛上午颓了一上午有题。然后，什么资料没看，装作都懂的样子。 下午进考点，与一个同学一起挤到前面，身后一群27中的占领了整条路。。。这就是搞OI和不搞OI的学校的区别吧。。。 进考场，我很淡定的答题，完了4：00就写完了。于是检查结果改错了一道8分的题，听说不给带试卷，于是机智的我将答案抄到了我的课表上算不算作弊啊，出考场，对答案，还好，75，应该能过了。 晚上上洛谷颓，结果被3个巨佬吊打，果断走了。 10.16上午学校指导老师亲自找我，我一脸懵：我怎么就71？？？ 然而还是过了线，而且我们学校只有两个人过了线 11.9下午上机。旁边坐这一个淮南的小学生一口方言，还啥都不知道，说起来都5年级了。长得像个1年级的 在中心考场，最后一个座位？？？试机打了个线段树，竟然打炸了…… 回洛谷把二分图匹配水过去了，然后发了一篇题解攒RP。 祝NOIP2018RP++！ 11.10上午一觉睡到10点多，起来，到洛谷上颓了一会，然后吃饭后被逼去写作业了。。。 下午1:50到考点。我在第10考场，结果第10考场的牌子都没举起来？？？害我找半天 跟着大部队，到了考场，发现同校的巨佬@柳暗花明 没来？然而还是来了 发密码了。看到密码的时候，我整个人都惊了：密码这么简单，我怎么没猜到？ 没错，就是这个密码： &amp;GaiGeKaiFang(40)Nian （改革开放40年） 可见OI有时是与政治相关的…… 解开，看第1题……竟然卡了好久，因为看到输入可能包含数字、字母、空格和换行符，想了半天还能有啥？然后就把这几个判了，还好，会谷一测对了。 T2把我吓到了…… 我果断开始暴力模拟，终于过了2个小样例…… 然而，大样例WA了！！！ 我立刻开始慌…… 然后想到洛谷11月月赛给我的教训： 三年OI一场空，不开long long见祖宗于是果断加了long long，还好，过了 看到T3，我又疯了…… 怎么T3就上DP了！！！果断去看T4 然而看了之后 我还是去打T3吧 我使尽所有智力，打出一个DP。 我修改了一下，结果 机子死机了！NOI Linux系统差评 NOIP 机房差评 把监考老师喊来，重启，好不容易进了系统，guide又崩了…… guide差评 无奈的我只好到旁边去考了……f**k！ 拷程序的时候死慢，我的程序当时是不小心写成了死循环，结果运行文件2.2G……系统被我搞坏了，溜了溜了 换新机子成功打完了T3……然而大样例WA了……考场上实在调不出来，于是又转头去攻T4了 T4先开始信心满满，越打越不会，最后放弃了，拿了3个点，还有一个神奇的rand 剩下来的时间颓废 收程序的时候，我旁边那个小朋友的程序我看到了 怪不得他写那么快！他T1写了个title.cpp输出第1个样例，title.cpp2输出第2给样例，第3个没输出…… 4题都这样 我的内心：仰望高端玩家 11.11上午上谷测了一下，264，慌的要死其实后来官方数据把我卡到了210 大概要退役了吧 明年的省赛不打算参加了，打算好好搞文化课，所以 谨记我逝去的初二OI！也祝大家能获得一个好成绩 另：如果你真的爱OI，一定要到一个重视OI的学校去啊！]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
